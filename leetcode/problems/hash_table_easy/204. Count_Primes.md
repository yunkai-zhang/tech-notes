### [204. Count_Primes](//leetcode.com/problems/count-primes/)

---

#### V1自己写质数识别函数，本来超时，根据大佬指点后，没超了

**中心思想：**
- 遍历所有小于n的非负数，分别判断他们是不是质数

**注意点：**
- 用求余法判断质数时，要确定n为质数，不需要每个比n小的数都不被整除（被大佬指点前我的算法）。只需要小于！等于！根号n的数不被整除即可（被大佬指点的地方，节约了不少运算时间）
- 求次方公式记住：<br />
Math.pow(底数，指数)；且此公式里，*指数不能是分数*。<br />
j* j=n，这种粗暴的次方计算也是一种方法

**算法描述**
1. 遍历小于n的非负数，判断他们是不是质数
2. 利用求余法，让n除以所有小于等于根号n的正整数，如果都不能整除则n为质数
3. 每次探测到n为质数则计数器加一，最后返回计数器结果

**代码：**
```java
public int countPrimes(int n) {
    //得自己把判断质数的函数写出来
    
    //遍历1：n-1，（即小于n的非负数）一旦发现质数，则numPrime++;
    int numPrime=0;
    for(int i=1;i<n;i++)
    {
    	//自己写了一个质数判断函数，一旦判断是质数，则统计质数的数目加1
        if(isPrime(i))
           numPrime++; 
    }
    
    return numPrime;
}
//自己写的用于判断质数的函数
public boolean isPrime(int num)
{
	//1不是质数
    if(num==1)
        return false;
    // for(int j=2;j<num;j++)没必要遍历直到num，其实5*5=25=n，所以只要遍历到根号n。若没有任何数能
    //整除n，即可判断n是一个质数
    
    //求次方公式记住：Math.pow(底数，指数)；
    
    //double pwn=Math.pow(num,1/2);得到错误结果，因为
    /*
    Math.pow(x,y)这个函数是求x的y次方，x，y的值都是浮点类型的，pow(64,1/3)，64的1/3次方，
    如果口头上来算的话，可以看成64的3次方根，但是计算机不会这样算，他会先求出1/3的值，1/3中1和3均为int类型，
    所以值为0，然后y这个值是浮点类型，所以自动转换为0.0，任何数字的0次幂都为1，所有这个地方求出来的值为1，而不是4
：https://blog.csdn.net/weixin_30363263/article/details/80865836
    */
    
    //这里经过大佬提醒，不用遍历到n-1。比如n=25，只要i=2~5之间没有能整除25的，i超过五的时候也不会有。因为i=根号n时，其左右的
    //i值其实在乘法上是互补的
    for(int j=2;j*j<=num;j++)
        if(num%j==0)//表示与某比自己小的数可整除
            return false;
    
    //既不等于1，又与别人相除非整除，则为质数
    return true;
}
```
---

#### V2,大佬利用[埃拉托斯特尼筛法求质数](https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95)



**中心思想：**
- 把每个质数的倍数都在数组（本次使用布尔数组）中进行标记。最后查看没被标记的即为质数。



**注意点**

- 初始化布尔数组，但是不赋值时，默认值是false。类似的如int数组默认值是0。
[其他java数据类型默认值，点这里](https://zhidao.baidu.com/question/2272400812846317148.html)


**算法描述：**

1. 先初始化一个长度为n的数组，来标记小于n的每个数是否为质数
2. 从2开始遍历，因为这是第一个质数。把2的所有倍数所在index的值设为true，表示2的倍数在之后遍历中不会再被考虑为质数
3. 之后如果当前i对应的boolean值是false，表示还没被处理，那他必定是质数（埃拉托斯特尼筛法思想）<br/>
eg：标记完质数2的倍数后，质数3不会被标记。标记完质数3的倍数后，非质数9会被标记，到时候就不会考虑他为质数
4. 每次碰到boolean为false的值（未标记过，为质数）时，质数数目计数器加一
5. 程序结尾返回质数数目计数器的值



**代码：**

```java
public class Solution {
    public int countPrimes(int n) {
    	//初始化布尔数组准备做标记，没错初始化，所以所有项的默认值是false
        boolean[] notPrime = new boolean[n];
        //设置质数数目计数器
        int count = 0;
        //从2开始判断谁是质数
        for (int i = 2; i < n; i++) {
        	//如果当前布尔值没被标记，表示当前值是质数（埃拉托斯特尼筛法思想）
            if (notPrime[i] == false) {
            	//如果当前是质数，质数计数器加一
                count++;
                //且把当前质数的所有整数倍index处存的布尔值标记为true（与false相对），体现那些index不再可能是质数了
                //只要质数的倍数比n小，就一直往后标记
                for (int j = 2; i*j < n; j++) {
                    notPrime[i*j] = true;
                }
            }
        }
        //返回质数标记器的值
        return count;
    }
}
```

