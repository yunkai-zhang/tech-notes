### [96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)

dynamic programming, tree

---

#### V1，大佬，数学加上动态规划

**中心思想：**
- 如果问题问数目或者true or false，那么一般可以考虑动态规划
- 加入g[n]是指n个节点能构成多少二叉搜索树。那么对于每个节点，其可能的二叉搜索树的数目=该节点左侧所有节点可能构成的二叉搜索树的数目*该节点右侧所有节点
可能构成的节点数目。而g[0]=g[1]=1，因为没有节点或者只有一个节点的时候肯定只能有一种二叉搜索树。
所以可以递归的，用g[0]g[1]求g[2],再用g[0]g[1]g[2]求g[3]。最后可以求出g[n]为多少。

**代码：**
```java
public int numTrees(int n) {
  int [] G = new int[n+1];
  G[0] = G[1] = 1;
    
  for(int i=2; i<=n; ++i) {
    for(int j=1; j<=i; ++j) {
      //G[j-1]表示j节点左边那么多节点可能构成的二叉搜索树的数目。G[i-j]表示j节点右侧一直到i（最后一个节点）的那么多节点数能构成的二叉搜索书的数目   
      G[i] += G[j-1] * G[i-j];
    }
  }
  return G[n];
}
```

---

#### V2,默写v1

**代码：**
```java
class Solution {
    public int numTrees(int n) {
        /*求数目或者trueorfalse的时候，往往可以考虑动态规划
        
        动态规划是先解决小问题，再利用小问题的结果解决大问题。本题如果g[n]是n个节点能构成的二叉搜索书的个数，
        那么g[0]=g[1]=1，这是显然的。然后，对于一串节点，其中的每个节点g[i](第i个节点)都能做二叉搜索树的根节点。
        那么对于每个节点做根节点的情况，其可能的二叉搜索树的个数=g[i-1]（第i个节点左边的所有节点，i从1开始）*g[n-i]
        （第i个节点右边的所有节点）。那么n个节点可能构成的二叉搜索树的个数等于这些节点对应乘积的和。*/
        
        //g[n]是n个节点能构成的二叉搜索书的个数。因为g[0]存在,且g[n]也存在（并且是要求的），所以需要n+1个节点
        int[] g=new int[n+1];
        //如果是空节点或者只有一个节点，那么肯定只能有一种二叉搜索树。
        g[0]=g[1]=1;
        
        /*因为g[0]g[1]都已知，所以从g[2]开始求。
        
        每个i对应求i个节点能形成都少中二叉搜索树。即每个i对应求一个g[i];
        
        i从小到大，是因为求g[大i]需要g[小i]的值，比如g[2]=g[0]*g[1]+g[1]*g[0]。*/
        for(int i=2;i<=n;i++)
        {
            /*每个j用于求每个g[i]。g[i]是一系列乘项相加而成，而j构成了这些乘项*/
            for(int j=0;j<i;j++)
            {
                /*求每个g[i]
                
                之所以可以+=，是因为g[i]默认的初始值是0。所以g[i]+=意味着等式右边所有项连加
                
                连加的那个乘项，一个不断加，一个不断减。具体怎么设置乘法项可以参考简单例子
                “g[2]=g[0]*g[1]+g[1]*g[0]”。第一个子项对应j=0的时候，为g[0]*g[2-1-0]。
                第二个子项对应j=1的时候，为g[1]*g[2-1-1]*/
                g[i]+=g[j]*g[i-1-j];
            }
        }
        
        //迭代完里，所有小于等于n数目的节点能构成的二叉搜索树的数目都被保存了,返回n对应的值就可
        return g[n];
        
    }
}
```
