# computer_network_hnust

课程来源：[mooc](https://www.icourse163.org/course/HNKJ-1461816178)，包含学习所需要的课件，各章小结讲的**思维导图**，工具包等一切资源。想学习时搭配弹幕+字幕的话，推荐课程视频观看[bilibili](https://www.bilibili.com/video/BV1c4411d7jb?from=search&seid=13092588426906504952&spm_id_from=333.337.0.0)

学习方式：建议抓大放小，用的不频繁或者不重要的就听了记个定义。重要的才记完整概念实例和老师说了什么。

笔记说明：标题带`！`表示课程老师说的重点。标题带`。`表示课程老师说了解即可。

## 概述

### 计算机网络在信息时代的作用

略

### 因特网概述

#### ！网络，互联网和因特网

1，网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成。

![image-20220123153009745](computer_network_hnust.assets/image-20220123153009745.png)

- 注意图片中的连接器是方形的，后面还会有圆形的。

2，多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网（或互连网)。因此，互联网是“网络的网络(Netwrok of Networks) "。

![image-20220123153124442](computer_network_hnust.assets/image-20220123153124442.png)

3，因特网(Internet)是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计)，在图像中常常用一朵云表示。

![image-20220123153158035](computer_network_hnust.assets/image-20220123153158035.png)

4，区分两个单词，internet与lnternet的区别：

- internet(互联网或互连网)是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。
- Internet(因特网)则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP/IP协议族作为通信的规则，其前身是美国的ARPANET。



5，（不重要）因特网发展的三个阶段

![image-20220123153636339](computer_network_hnust.assets/image-20220123153636339.png)

#### ISP

1，即因特网服务提供者（internet service provider）。像移动，联通，电信，都是ISP。

![image-20220123153907516](computer_network_hnust.assets/image-20220123153907516.png)

2，基于ISP的三层结构的因特网

![image-20220123154057745](computer_network_hnust.assets/image-20220123154057745.png)

- 第一层isp的服务面积最大，一般称为因特网主干网，覆盖国际性区域范围，并拥有高速链路和交换设备；第一层isp之间直接互联。

- 第二层isp和一些大公司都是第一层isp的用户，具有区域性或者国家性覆盖规模，和少数第一层ISP相连接。

- 第三层isp又称为本地isp，他们是第二层isp的用户，且只拥有本地区域的网络；一般校园网或者企业网或者住宅用户都是第三层ISP的用户。

- 因特网逐渐演变成基于ISP的多层次结构网络，但是现在网络太大，很难对整个网络的结构给出细致描述。相隔遥远的主机间通信可能需要经过多个ISP：

  <img src="computer_network_hnust.assets/image-20220123154836277.png" alt="image-20220123154836277" style="zoom:50%;" />

- 任何人如小明只要可以接入因特网就可以成为isp，需要做的就是购买一些调制解调器或者路由器，让其他用户可以和小明相连即可。



#### 因特网组成

![image-20220123155311517](computer_network_hnust.assets/image-20220123155311517.png)

- 边缘部分：由所有连接在因特网上的**主机**组成。这部分是**用户直接使用**的，用来进行通信（传送数据、音频或视频）和资源共享。
- 核心部分：由大量**网络**和连接这些网络的**路由器**组成。这部分是为边缘部分提供服务的(提供连通性和交换)。
  - 在网络核心部分起重要作用的是路由器，他是一种专用计算机，但是我们不称之为主机。路由器是实现分组交换的关键构建，其任务是转发收到的分组（网络核心部分最重要的功能）。



### 三种交换方式

#### 电路交换(Circuit Switching)

1，交换机的出现可以减少电话线的使用：

![image-20220123160536433](computer_network_hnust.assets/image-20220123160536433.png)

- 电话交换机接通电话线的方式称为**电路交换**;

- 从通信资源的分配角度来看，**交换**(Switching)）就是按照某种方式**动态地分配**传输线路的**资源**;

2，电路交换的三个步骤：

![image-20220123160913554](computer_network_hnust.assets/image-20220123160913554.png)

1. 建立连接(分配通信资源)
2. 通话（一直占用通信资源)
3. 释放连接(归还通信资源)

3，电路交换可以实现计算机间的数据传送，但是线路的传输效率很低。因为：

- 计算机的数据是突发式得出现在传输线路上。
- 例如，用户在打字的时候要时间，但是这个时候通信资源暂时没被利用，且不能被其他用户利用，白白浪费了通信资源。
- 所以**计算机**网络通常采用**分组交换**，而不是电路交换。

#### ！分组交换(Packet Switching)

1，因特网中，**最重要**的分组交换机就是**路由器**。路由器把各种网络互联起来，并对接收到的分组进行转发（也即“分组交换”）。

2，分组交换的各方角色：

**![image-20220123162732112](computer_network_hnust.assets/image-20220123162732112.png)**

- 发送方：构造分组；发送分组。
  - 构造分组的时候给每段数据分配数据头（即包头），构成数据包，包头中存储着“发送目的地”等重要信息。
- 路由器：缓存分组；转发分组。
- 接收方：接收分组；还原报文。
  - 接收分组的时候，根据数据包的包头中的信息，把接收到的数据整合还原。

#### 报文交换(Message Switching)

不怎么使用了，不讲。



#### 交换方式对比

1，图示：

![image-20220123163109989](computer_network_hnust.assets/image-20220123163109989.png)

- 电路交换
  - 建立连接后，比特流直达终点。
- 报文交换
  - 不限制报文的大小，需要各节点交换机有较大的缓存空间。
- 分组交换
  - 比报文交换减少了转发时延
  - 避免过长的报文长时间占用链路，同时有利于进行差错控制。
  - 我认为：“分组交换比报文交换先进一点点，因为它把原始报文分成了一个个组”。
- 
- 电路交换和tcp链接类似，报文交换和udp连接类似。

2，优缺点对比：

- 电路交换

  - 优点
    - 通信时延小（实时性强）：因为通信线路为通信双方用户专用，数据直达，因此通信时延非常小。当连续传输大数据时，这个优点就很明显。
    - 有序传输：通信双方之间只有一条专用的通信线路，数据只在这一条线路上传输，不存在失序问题。
    - 不存在冲突：不同的冲突双方有不同的信道，不会出现争抢物理信道的问题。
    - 适用范围广：电路交换既适用于传输模拟信号，也适合传输数字信号。
    - 控制简单：电路交换的节点交换机及其控制都比较简单。

  - 缺点：
    - 建立效率：电路交换的平均连接建立时间对计算机通信来说太长了
    - 使用效率低：线路独占，即使线路空闲也不能被其他用户使用
    - 灵活性差：只要连接所建立的物理通路的任意一点出现了故障，就必须拨号建立新的连接，对紧急和重要的通信是不利的。
    - 难以规格化：电路交换时数据直达，不同类型，不同规格，不同速率的终端很难相互进行通信；也难以在通信过程中进行差错控制。

- 报文交换：
  - 优点：
    - 无需建立连接：报文双方无需为通信双方预先建立一条专用的通信线路，不存在建立连接的时延，用户可以随时发送报文。
    - 动态分配线路：发送方把报文传送给节点交换机是，节点交换机先存储整个报文，然后选择一条合适的空闲线路，将报文发送出去。
    - 提高线路可靠性：如果某条传输路径发生故障，会重新选择另一条路径传输数据。
    - 提高线路利用率：通信双方不是固定占用一条通信线路，而是在不同的时间分段占用物理线路。
    - 提供多目标服务：一个报文可以同时发送给多个目的地址，这在电路交换中是很难实现的。
  - 缺点
    - 引起了转发时延：因为报文在节点交换机上要经历存储转发的过程。
    - 需要较大的存储缓存空间：因为报文交换对报文的大小没有限制。
    - 需要传输额外的信息量：这是因为报文需要携带目标地址，源地址等。

- 分组交换：
  - 优点：
    - 无需建立连接：分组交换不需要为通信双方预先建立一条专用的通信线路，不存在建立连接的时延，用户可以随时发送分组。
    - 线路利用率高：通信双方不固定占用一条通信线路，而是在不同的时间分段占用物理线路。
    - 简化了存储管理：这是相对于报文交换而言的，分组的长度固定，相应的缓冲区的大小也固定，管理起来相对容易。
    - 加速传输：由于分组是逐个传输的，使得后一个分组的存储操作和前一个分组的转发操作可以同时进行。
    - 减少出错概率和重发数据量：这也是相对于“报文交换而言的，因为分组比报文小，因此出错概率必然减小；即使分组出错也只需要重传出错的分组，比重传整个报文的数据量小很多。提高了可靠性，减少了传输时延。
  - 缺点：
    - 引起了转发时延：分组在节点交换机上要经历存储转发的过程。
    - 需要传输额外的信息量：将原始报文分割成等长的数据块，每个数据块都要加上“源地址”和“目的地址”等控制信息从而构成分组，因此使得传送的数据量增大了。
    - 分组交换采用数据包服务时，可能会出现“失序”“丢失”“重复分组”
    - 分组到达目的节点是，需要重新还原成原始报文，比较麻烦。
    - （**虚电路服务**是指是一种面向连接的，使所有分组顺序到达目的端的可 靠性数据传输服务）。若分组交换采用虚电路服务，虽然没有分组失序的问题，但是有”呼叫建立，数据传输，虚电路释放“三个过程。

### 计算机网络的定义与分类

#### 计算机网络的定义

1，计算机网络的精确定义并未统一：

2，计算机网络的最简单的定义是:一些**互相连接**的、**自治**的计算机的**集合**：

- 互连：计算机之间可以通过有线或者无线的方式进行数据通信。

- 自治：指独立的计算机，有自己的软件和硬件，可以单独运行。

  <img src="computer_network_hnust.assets/image-20220123194048977.png" alt="image-20220123194048977" style="zoom:50%;" />

  - 比如本图系统就不是一个计算机网络，因为图中终端只有输入和显示功能，不是自治的计算机。

- 集合：至少需要两台计算机。

3，目前计算机网络的较好定义是：计算机网络主要是由一些**通用的**、**可编程的硬件**互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来**传送多种不同类型的数据**，并能**支持广泛的和日益增长的应用**。

- 计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。

- 计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用)。



#### ！计算机网络分类

![image-20220123210225297](computer_network_hnust.assets/image-20220123210225297.png)

- WAN：广域网。可以覆盖一个国家，地区，甚至横跨几个大洲。是因特网的核心部分，其任务是为核心路由器提供远距离（如跨越不同国家）的高速连接，互联分布在不同区域的城域网和局域网。
- MAN：城域网。一般覆盖几个街区或者是一个城市。

- LAN：局域网。一般是用微型计算机或工作站通过高速通信线路相连，速率常在10Mb/s以上；地理上较小，如一个校园或者实验室。局域网通常由某个单位单独拥有使用和维护。
- PAN（WPAN）：个域网。不同于上述网络，不是用来连接普通计算机的；而是在个人工作的地方把属于个人使用的电子设备如“laptop，鼠标，耳机等”用无线技术连接起来起来的网络。覆盖范围大概为10米。



### 计算机网络的性能指标

#### 性能指标介绍

定义：性能指标可以从不同的方面里度量计算机网络的性能。

常用的计算机网络性能指标：

- 速率，带宽，吞吐量，时延，时延带宽积，往返时间，利用率，丢包率



#### 速率

1，了解速率要先了解bit：

- 比特是计算机中**数据量**的单位，也是信息论中信息量的单位。一个比特就是二进制数字中的一个1或0。

- 常用的数据单位：

  ![image-20220124131558808](computer_network_hnust.assets/image-20220124131558808.png)

- 厂家硬盘标单位250GB，但是操作系统标注的确实232GB，原因如下：

  ![image-20220124132227199](computer_network_hnust.assets/image-20220124132227199.png)

  - 厂家（红色标注）的单位中的G为10的9次方；
  - 操作系统（蓝色标注）的单位中的G为2的30次方。

2，**速率**定义为：

- 连接在计算机网络上的主机在数字信道上传送比特的速率，也称为**比特率**或**数据率**。

- 数据量和数据率的单位对比

  ![image-20220124132917584](computer_network_hnust.assets/image-20220124132917584.png)

  - 数据量中K为2的10次方，数据率中k为10的3次方，原因是：数据量bit或byte是给计算机人看的，速率（数据率）是给大众看的

3，体现数据量和数据率单位差别的例题：

![image-20220124133347715](computer_network_hnust.assets/image-20220124133347715.png)

- 数据量的M**默认**时的值为2的20次方；如果场景中指明数据量的M为10的6次方，则以场景为准。



#### 带宽

1，带宽在模拟信号系统中的意义：

- 定义：**信号**所包含的各种不同频率成分所占据的**频率范围**;

- 单位：Hz (kHz，MHz，GHz)

- 带宽举例：在传统的通信线路上传送的电话信号的标准带宽为3.1kHz，范围从300Hz到3.4kHz；这是语音的主要成分的频率范围；3.1k=3.4k-0.3k。

  ![image-20220124134418059](computer_network_hnust.assets/image-20220124134418059.png)

2，带宽在计算机网络中的意义：

- 定义：用来表示网络的**通信线路**所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“**最高数据率**”;
- 单位：b/s (kb/s,Mb/s,Gb/s,Tb/s)。和刚介绍的速率（数据率）的单位相同。
- 现实生活例子：有人为“你家出口网速多少”，答曰“200M”。这里的“200M”其实省略了“bit/s”和“最高速率”；完整地回答应该是“最高速率为200Mb/s"。
  - 这里的“最高速率”其实就是我家网络的出口带宽。

3，模拟信号和计网中带宽的联系：

- 其实，“带宽”的这两种表述之间有着密切的联系。一条通信线路的“频带宽度”越宽,其所传输数据的“最高数据率”也越高。



#### 吞吐量

1，定义：吞吐量表示在**单位时间内通过某个网络(或信道、接口)的数据量**。

- 吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。
- 吞吐量**受网络的带宽或额定速率的限制**。

2，例子：

![image-20220124141309172](computer_network_hnust.assets/image-20220124141309172.png)

- 本以太网的吞吐量受带宽限制，最高为1Gb/s，通常只能达到700Mb/s。

- 计算机网络的带宽是理想，吞吐量是现实。



#### ！时延

1，网络时延的构成：

![image-20220124142143794](computer_network_hnust.assets/image-20220124142143794.png)

2，时延成分讲解：

- 发送时延：

  - 公式：

    ![image-20220124141633428](computer_network_hnust.assets/image-20220124141633428.png)

  - 发送时延受“网卡发送速率，信道带宽，接口速率”共同影响；基本符合短板效应：

    ![image-20220124141811817](computer_network_hnust.assets/image-20220124141811817.png)

  - 构建网络时，应该做到各设备间以及传输介质的**速率匹配**，这样才能发挥出本应具有的传输性能。

    

- 传播时延：

  - 公式：

    ![image-20220124142709635](computer_network_hnust.assets/image-20220124142709635.png)

- 处理时延：
  - 公式：不方便计算，公式不存在。
  - 各种路由器的软硬件性能不同，路由器的繁忙时段不固定
  - 关于有些教材中的“排队时延”：本课程把“排队时延和处理时延”合并称为”处理时延“；关于处理时延的考题中，往往指明“处理时延忽略不计”。

3，例题：

![image-20220124143331716](computer_network_hnust.assets/image-20220124143331716.png)

- 这里”电磁波传播速率“未指定传播介质，那就使用默认的光纤中数据率。
- 两个例子看出，**时延的大头不一定**，要具体问题具体分析。



#### 时延带宽积

1，公式：

![image-20220124144132627](computer_network_hnust.assets/image-20220124144132627.png)

- 注意这里的时延是“传播时延”，而不是完整的网络时延

2，理解：若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特;

![image-20220124144250388](computer_network_hnust.assets/image-20220124144250388.png)

- 链路的时延带宽积又称为**以比特为单位的链路长度**。



#### 往返时间

1，概念：

- 在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互;我们有时很需要知道双向交互一次所需的时间;因此，往返时间**RTT**(Round-Trip Time)也是一个重要的性能指标。

2，实例：

![image-20220124144709229](computer_network_hnust.assets/image-20220124144709229.png)

- 本例子中，卫星链路的“传播时延”耗时较多！！这是卫星链路的特性决定的。



#### ！利用率

1，构成：

- 信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)。
- 网络利用率：全网络的信道利用率的加权平均。

2，根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加；因此，信道利用率并非越高越好。

3，公式分析（我感觉不重要，记住结论就行）：

![image-20220124145622490](computer_network_hnust.assets/image-20220124145622490.png)

- 信道利用率不能太低，也不能太高。



#### 丢包率

1，定义：

- 丢包率即分组丢失率，是指在一定的时间范围内，传输过程中**丢失的分组数量与总分组数量的比率**。

2，丢包率分类：

- 丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。

3，丢包率是网络运维人员非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。

4，分组丢失的两种主要情况：

- 分组在传输过程中出现误码，被结点丢弃;
- 分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成网络拥塞。

5，丢包率反映了网络的拥塞情况：

- 无拥塞时路径丢包率为0
- 轻度拥塞时路径丢包率为1%~4%
- 严重拥塞时路径丢包率为5%~15%



### ！计算机网络体系结构（重难点）

#### 常见的计算机网络体系结构

1，OSI对比TCP/IP：

![image-20220124154552886](computer_network_hnust.assets/image-20220124154552886.png)

- 记忆OSI，从1到7，即从底层到顶层为：**p**lease **d**o **n**ot **t**hrow **s**ausage and **p**izza **a**way。
- 很多公司把自己订立的标准推动为国际标准就是为了利益
- 某种意义上来说，能够占领市场的就是标准。TCP/IP体系就够就占据了市场。

2，OSI失败原因：

- OSI专家缺乏实际经验，完成OSI标准时没有商业驱动力

- OSI协议实现起来过分复杂，且运行效率低。
- OSI标准的指定周期太长，使得按OSI标准生产的设备无法及时进入市场。
- OSI层次划分不太合理，有些功能在多个层次中重复出现。

3，TCP/IP体系结构的**层次**和层次中的**协议**：

![image-20220124155259397](computer_network_hnust.assets/image-20220124155259397.png)

- 网络接口层没有规定具体的内容，这是为了互联全世界不同的网络接口，如“有线的以太网接口，无线局域网的wifi接口”等等。

- 路由器中只有“网际层和网络接口层”。
- 网际层协议：除了ip还有ICMP协议。

4，学习计网时实际学习的“原理体系结构”：

![image-20220124160124470](computer_network_hnust.assets/image-20220124160124470.png)

- 由于网络接口层没有规定具体的内容，对于学习计算机网络的完整体系而言会缺少一部分内容，因此在学习计算机网络原理时往往采用折中的办法，综合OSI和TCP/IP的优点，采用五层协议的“原理体系结构”。
- 把TCP/IP体系结构的“网络接口层”又拆开，“网际层”又称为网络层。



#### 计算机网络分层的必要性

1，**计算机网络是个非常复杂的系统**。早在最初的ARPANET设计时就提出了分层的设计理念。"**分层**"可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。下面，我们按照由简单到复杂的顺序，来看看实现计算机网络要面临哪些主要的问题，以及如何将这些问题划分到相应的层次，层层处理。

2，物理层解决的问题。从一个电脑往另一台电脑发送消息，要解决如下问题：

![image-20220124163212060](computer_network_hnust.assets/image-20220124163212060.png)

3，数据链路层要解决的问题：

![image-20220124163304705](computer_network_hnust.assets/image-20220124163304705.png)



4，网络层要解决的问题：

![image-20220124163939341](computer_network_hnust.assets/image-20220124163939341.png)

- 每天使用的因特网是用很多的网络和路由器互连起来的，仅解决物理层和数据链路层的问题还是不能正常工作。
- 图中“Nx”表示一个网络；本例中网络的前三段是网络位，最后一位是网络（局域网）中用于标记主机的位；这里相当于是把完整地网段192.168.x.x划分为四个子网段，第三段用来区别不同的子网，第四段用来在子网内部区别不同的主机。



5，运输层要解决的问题：

![image-20220124164522182](computer_network_hnust.assets/image-20220124164522182.png)

6，应用层要完成的任务：

![image-20220124164956672](computer_network_hnust.assets/image-20220124164956672.png)

- 在“物理层，数据链路层，网络层，传输层”的基础上，只需要制定各种应用层协议，并按协议层标准编写相应的应用程序，通过应用进程间的交互来完成特定的网络应用（如HTTP SMTP等）。



7，总结“原理体系结构”各层的任务：

![image-20220124165202086](computer_network_hnust.assets/image-20220124165202086.png)

- 相比于把五层的问题放在一个模块中实现，现实中我们肯定选择把五层的问题分模块各自解决，这就是“原理体系结构”分层的意义。



#### 分层思想举例

1，请求方请求后，服务端返回信息的实例如图：

![image-20220125163209568](computer_network_hnust.assets/image-20220125163209568.png)

![image-20220124195846102](computer_network_hnust.assets/image-20220124195846102.png)

- “自顶向下”指的是，数据传输时，按照“应用层-》传输层-》网络层-》数据链路层-》物理层”的顺序自顶向下得一层层添加本层的报头，最后通过物理层传输。接收方的物理层收到信息后，根据每层的报头，自下向顶得剥离层，最后由应用层取回数据。

2，请求发送的步骤讲解：

1. 应用层构建http报文；并将http报文交给运输层

   <img src="computer_network_hnust.assets/image-20220124200524782.png" alt="image-20220124200524782" style="zoom:50%;" />

2. 运输层给http请求添加一个tcp首部，使之成为TCP报文段；并把TCP报文段交付给网络层处理：

   <img src="computer_network_hnust.assets/image-20220124200812470.png" alt="image-20220124200812470" style="zoom:50%;" />

   - TCP首部的作用主要是为了区分应用进程，以及实现可靠传输

3. 网络层给TCP报文段添加一个IP首部，使之成为IP数据报；并把ip数据报交付给数据链路层处理：

   <img src="computer_network_hnust.assets/image-20220124201607472.png" alt="image-20220124201607472" style="zoom:50%;" />

   - ip首部的作用主要是为了使IP数据报可以在互联网上传输，也就是被路由器转发。

4. 数据链路层给ip数据报添加一个首部和尾部，使之成为帧；并把帧交付给物理层：

   <img src="computer_network_hnust.assets/image-20220124202143284.png" alt="image-20220124202143284" style="zoom:50%;" />

   - 首部：假设网络N1是以太网的话，以太网首部的格式如本图所示。该首部的作用主要是为了让帧能在一段链路上或者一个网络上传输，能够被相应的目的主机接收。
   - 尾部：假设网络N1是以太网的话，以太网尾部的格式如本图所示。其尾部是为了让目的主机检查所接收到的帧是否有误码。

5. 物理层将帧看做是比特流；将添加有前导码的比特流变化成相应的信号发送到传输媒体，信号通过传输媒体到达路由器：

   <img src="computer_network_hnust.assets/image-20220124202632319.png" alt="image-20220124202632319" style="zoom:50%;" />

   - 由于网络N1是以太网，所以物理层还会给该比特流前面添加前导码；前导码的内容如本图所示。其前导码的作用是为了让目的主机做好接收帧的准备。

6. 路由器接收到信号后，将信号变换成比特流；然后去掉前导码后，将其交付给数据链路层，实际上交付的是帧：

   <img src="computer_network_hnust.assets/image-20220124202856275.png" alt="image-20220124202856275" style="zoom:50%;" />

7. 数据链路层将帧的首部和尾部去掉后，将其交给网络层，这实际交付的是IP数据报

   <img src="computer_network_hnust.assets/image-20220124203119965.png" alt="image-20220124203119965" style="zoom:50%;" />

8. 网络层解析数据报的首部，从中提取出目的网络地址，然后查找自身的路由表，确定转发端口，以便进行转发：

   <img src="computer_network_hnust.assets/image-20220124203348325.png" alt="image-20220124203348325" style="zoom:50%;" /><img src="computer_network_hnust.assets/image-20220124203437285.png" alt="image-20220124203437285" style="zoom:50%;" />

   

9. 然后的发送就是类似的步骤不断循环。。。

3，服务器接收请求的步骤相当于发送步骤的逆，不多赘述。



#### 专用术语

专业术语来自OSI的七层体系结构，但也适用于TCP/IP的四层体系结构，也适用于五层协议原理体系结构。我们将专业术语中最具有代表性的三个作为分类名称，分别是“实体，协议，服务”。

1，实体：

![image-20220124204150588](computer_network_hnust.assets/image-20220124204150588.png)

- 实体定义：任何可发送或接收信息的**软件进程**或**硬件**。本图中AB..J都是实体。
- 对等实体：收发双方**相同层次中的实体**。本图中，通信双方的网卡是对等实体（硬件），通信双方中的正在进行通信的应用进程是对等实体（软件）。

2，协议：

![image-20220124204705396](computer_network_hnust.assets/image-20220124204705396.png)

- 协议定义：控制两个对等实体进行**逻辑通信**的规则的集合。
  - 之所以称为逻辑通信，是因为这种通信实际上并不存在，它只是我们假设出来的一种通信。目的在于方便我们单独研究体系结构裳一层时，不用考虑其他层。例如，当我们研宽运输层时，我们可以假设运输层的对等实体在进行逻辑通信,而不用顾及其它层。

- 协议三要素：

  - 语法：定义所交换信息的格式。如本图，语法定义了所交换信息由哪些字段以及何种顺序构成。

    <img src="computer_network_hnust.assets/image-20220124205019051.png" alt="image-20220124205019051" style="zoom:50%;" />

  - 语义：定义收发双方所要完成的操作。即通信双方收到分组后要完成怎样的操作。

  - 同步：定义收发双方的时序关系。本图就可以看出TCP客户端和TCP服务器之间的时序关系，以及各自的状态转换，只有双方建立连接后，才能进行TCP传输；本图可以清晰的展示同步的概念。

    <img src="computer_network_hnust.assets/image-20220124205500233.png" alt="image-20220124205500233" style="zoom:50%;" />

3，服务：

![image-20220124210354948](computer_network_hnust.assets/image-20220124210354948.png)

- 服务定义：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。
  - 协议是“**水平的**”，服务是“**垂直的**”。
  - 实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议；也就是说，下面的协议对上面的实体是"**透明**"的。比如我们看得见手机为我们提供的服务，但我们只是享受手机提供的服务，而没必要弄懂手机的工作原理。
- 服务前提：要实现本层协议，还需要使用下面一层所提供的服务。
  - 例子：网络层“**享受**”链路层提供的服务，自己实现网络层协议并进行通信，并给运输层**提供**服务。

![image-20220124211022648](computer_network_hnust.assets/image-20220124211022648.png)

- 服务访问点：在同一系统中**相邻两层的实体交换信息的逻辑接口**，用于区分不同的服务类型。
  - 数据链路层的服务访问点为帧的“类型”字段。
  - 网络层的服务访问点为IP数据报首部中的“协议字段”。
  - 运输层的服务访问点为“端口号”
  - 本图中的小圆圈们就是服务访问点们
- 服务原语：上层使用下层所提供的服务必须通过与下层**交换一些命令**，这些命令称为服务原语。

![image-20220124211243385](computer_network_hnust.assets/image-20220124211243385.png)

- 协议数据单元PDU：**对等层次之间传送的数据包**称为该层的协议数据单元。

- 服务数据单元SDU：**同一系统内，层与层之间交换的数据包**称为服务数据单元。
- 多个SDU可以合成为一个PDU;一个SDU也可划分为几个PDU.

### 章节小结

若干折叠版mindmap提纲本章知识。略。可从bilibili老师的说明网址中获取（慕课）

### 习题课

全部学完再来做

https://www.bilibili.com/video/BV1c4411d7jb?p=12&spm_id_from=pageDriver



## 物理层

网友说：“各位，如果不是通信工程专业的大三以上学生想要听懂物理层的话，请先学习信号与系统，数字信号处理，概率论，线性代数，通信原理”。。我竟然都学过，通信转码党泪目。。

### ！物理层的基本概念

1，基本概念：

- 物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。
- 物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。



2，物理层传输媒体分类：

![image-20220125111725555](computer_network_hnust.assets/image-20220125111725555.png)

- 导引型传输媒体
- 非导引型传输媒体



3，物理层协议的主要任务：

- 机械特性：指明接口所用接线器的**形状**和**尺寸**、**引脚数目**和**排列**、**固定**和**锁定**装置。
- 电气特性：指明在接口电缆的各条线上出现的**电压的范围**。
- 功能特性：指明某条线上出现的某一电平的**电压表示何种意义**。
- 过程特性：指明对于不同功能的各种可能**事件的出现顺序**。

由于传输媒体的种类众多（双绞线，光纤），物理连接方式也很多（点对点，广播），因此物理层协议种类比较多。每种物理层协议都包含了上述四个任务的具体内容，因此在学习物理层时，应该将**重点放在掌握基本概念上**，而不是某个具体的物理层协议。



### 。物理层下面的传输媒体

请大家准意。传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将它放在物理层之下。



传输媒体分类为：

![image-20220125112912887](computer_network_hnust.assets/image-20220125112912887.png)



#### 同轴电缆

1，同轴电缆图示：

![image-20220125112952347](computer_network_hnust.assets/image-20220125112952347.png)

2，同轴电缆分类：

- 基带同轴电缆(50Ω)：数字传输，过去用于局域网
- 宽带同轴电缆(75Ω)：模拟传输，目前主要用于有线电视



3，同轴电缆已过时：

- 同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在**局域网**领域基本上都是采用**双绞线**作为传输媒体。



#### ！双绞线

1，双绞线分类与图示：

![image-20220125113510955](computer_network_hnust.assets/image-20220125113510955.png)

- 屏蔽双绞线电缆无屏敝观鲛线电缆增加了金属丝编织的屏蔽层,提高了抗电磁干扰的能力，当然价格也会更贵一点。



2，常用绞合线的详细信息表格：

![image-20220125113619168](computer_network_hnust.assets/image-20220125113619168.png)

- 目前家庭局域网主流带宽为1Gb/s，选用大品牌质量好的“超5类”双绞线电缆可以满足。考虑到未来发展，在经济条件允许的情况下，建议选用“6A类”双绞线电缆，以满足万兆局域网的需求。



#### ！光纤

1，光纤图示：

![image-20220125114323998](computer_network_hnust.assets/image-20220125114323998.png)

- 纤芯直径：

  - 多模光纤:50微米，62.5微米

  - 单模光纤:9微米

- 包层直径：125微米
- 工作波长：
  - 0.85微米(衰减较大)
  - 1.30微米（衰减较小)
  - 1.55微米（衰减较小)



2，光纤特点：

- 优点：
  - 通信容量大(25000~30000GHz的带宽)
  - 传输损耗小，远距离传输时更加经济。
  - 抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要。
  - 无串音干扰，,保密性好，不易被窃听。
  - 体积小，重量轻。
- 缺点：
  - 割接需要专用设备
  - 光电结构价格较贵



3，光在光纤中传播的基本原理：

![image-20220125114816454](computer_network_hnust.assets/image-20220125114816454.png)

![image-20220125115017140](computer_network_hnust.assets/image-20220125115017140.png)



#### 电力线

1，应用图示：

![image-20220125115353094](computer_network_hnust.assets/image-20220125115353094.png)



#### 非导引型传输媒体概述

可以利用电磁波在自由空间的传播来传输信息。

1，光的各频段的可用情况：

![image-20220125115541342](computer_network_hnust.assets/image-20220125115541342.png)

2，以下频段不用于电信领域

![image-20220125115638718](computer_network_hnust.assets/image-20220125115638718.png)



#### 无线电波

![image-20220125115758728](computer_network_hnust.assets/image-20220125115758728.png)

- 无线电波的中低频利用地面波传输；高频和甚高频利用带电离子层反射传输。

#### ！微波

![image-20220125120404221](computer_network_hnust.assets/image-20220125120404221.png)

- 微波会穿透电离层，因此它不能经过电离层的反射传播到地面上很远的地方。
- 同步卫星传递微波的话，覆盖范围广，但是传播时延大。



#### 红外线

![image-20220125120528619](computer_network_hnust.assets/image-20220125120528619.png)

- 笔记本电脑已经淘汰了红外接口，但是很多智能手机还带有红外接口，以方便用户对电视空调等家用电器进行红外遥控。



#### 可见光

LIFI通信，目前还在实验阶段。



本节“物理层下面的传输媒体”了解即可，所以在节标题前加上了“。”



### 传输方式

有以下传输方式：

![image-20220125121214159](computer_network_hnust.assets/image-20220125121214159.png)



#### ！串行+并行传输

1，图示：

![image-20220125121350752](computer_network_hnust.assets/image-20220125121350752.png)

- 串行传输是指数据是一个比特一个比特依次发送的，因此在发送端和接收端之间，只需要一条数据传输线路即可。
- 并行传输时指一次发送n个比特而不是一个比特，因此在发送端和接收端之间需要有n条传输线路。
- 并行传输的优点是速度是串行传输的n倍，但也存在一个严重的缺点，即成本高。

2，数据在计算机网络上使用的是串行传输

![image-20220125121705651](computer_network_hnust.assets/image-20220125121705651.png)

3，计算机内部数据传输，常采用并行传输方式：

![image-20220125121826625](computer_network_hnust.assets/image-20220125121826625.png)

- 如cpu和内存之间，通过总线进行数据传输。
- 常见的数据总线宽度为8位，16位，32位，64位。



#### ！同步+异步传输

![image-20220125122257642](computer_network_hnust.assets/image-20220125122257642.png)

- 同步传输会产生时差误差积累，所以需要双方进行时钟同步
- 异步传输要在每个字节前后加上起始位“S”和结束位“E”



#### 单工+半双工+全双工通信

![image-20220125122446945](computer_network_hnust.assets/image-20220125122446945.png)

- 单工例子：广播与收音机；半双工例子：对讲机；全双工例子：电话。
- 单向通信只需要一条信道；双向交替通信和双向同时通信则都需要两条信道（每个方向各一条）。



### 编码与调制

#### ！编码调制的概念，和码元定义

![image-20220125144722267](computer_network_hnust.assets/image-20220125144722267.png)



#### ！各种编码

1，不归0编码：

![image-20220125145036717](computer_network_hnust.assets/image-20220125145036717.png)

- 接收方按时钟信号的节拍来逐个接收码元。
- 由于不归零编码存在同步问题，**计算机网络**中的数据传输**不采用**这类编码。



2，归零编码：

![image-20220125145301461](computer_network_hnust.assets/image-20220125145301461.png)

- 归零编码的优点是自同步，但缺点是编码效率低。



3，曼彻斯特编码：

![image-20220125145620629](computer_network_hnust.assets/image-20220125145620629.png)

- 比如可以规定：负跳变表示比特1，正跳变表示比特0。



4，差分曼彻斯特编码：

![image-20220125145759986](computer_network_hnust.assets/image-20220125145759986.png)

- 它比曼彻斯特编码变化少，更适合较高的传输速率。



#### ！基本调制方法

![image-20220125150222134](computer_network_hnust.assets/image-20220125150222134.png)



- 使用基本调制方法，1个码元只能包含1个比特信息。如果想使1个码元包含更多的比特，就得使用混合调制。



#### 混合调制

![image-20220125150342173](computer_network_hnust.assets/image-20220125150342173.png)

![image-20220125150354858](computer_network_hnust.assets/image-20220125150354858.png)

- 可以同时调制“相位和振幅”



#### QAM举例

![image-20220125150606933](computer_network_hnust.assets/image-20220125150606933.png)

- 如果不采用格雷码，出现误差时，可能一下子四位全错！！



### 信道极限容量

#### 信道失真

![image-20220125150928241](computer_network_hnust.assets/image-20220125150928241.png)

- 失真严重时，信号波形失去了码元之间的清晰界限，这个现象叫做”码间串扰“



#### ！奈奎斯特准则

1，奈氏准则说明：

![image-20220125151746461](computer_network_hnust.assets/image-20220125151746461.png)

- 奈氏准则是在理想状态下推导出来的，它没有考虑“传输距离，噪声干扰”等因素，



2，”调幅调频调相“属于二元调制，只能产生两种不同的码元，也就是两种不同的基本波形，因此每个码元只能携带1bit的信息。



![image-20220125151355770](computer_network_hnust.assets/image-20220125151355770.png)

3，混合调制属于多元调制，比如QAM16可以调制处16种不同的码元，因此每个码元可以携带4bit的信息。

![image-20220125151415656](computer_network_hnust.assets/image-20220125151415656.png)

#### ！香农公式

![image-20220125151910272](computer_network_hnust.assets/image-20220125151910272.png)



#### ！综合奈氏准则和香农公式

![image-20220125152001775](computer_network_hnust.assets/image-20220125152001775.png)

### 章节小写

见mooc的mindmap

### 习题课

暂略



## 数据链路层

数据链路层常讨论的就是以太网上的问题，搞清楚这个以太网是什么；总线是什么。

### 数据链路层概述

#### 一些概念

![image-20220125163514226](computer_network_hnust.assets/image-20220125163514226.png)

- **链路**(Link)就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。
- **数据链路**(Data Link)是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。
- 数据链路层以**帧**为单位传输和处理数据。



#### 点对点信道的数据链路层的三个重要问题

![image-20220125163556480](computer_network_hnust.assets/image-20220125163556480.png)

1，封装成帧

![image-20220125163730824](computer_network_hnust.assets/image-20220125163730824.png)

- 发送数据时，自顶向下不断封装数据。
- 数据链路层的”帧“的结构如本图蓝色方框所示



2，差错监测：

![image-20220125164159904](computer_network_hnust.assets/image-20220125164159904.png)

- 帧在传输过程中，遭遇干扰后可能会出现误码，也就是比特0/1变成比特1/0.
- 接收方通过封装在帧尾的检错码，结合检错算法，就可以判断帧中是否出现了误码。



3，可靠传输：

![image-20220125164658232](computer_network_hnust.assets/image-20220125164658232.png)

- 接收方主机收到有误码的帧后，是不会接受该帧的，将其丢弃。
- 如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会有更多措施；如果数据链路层向其上层提供的是可靠服务，那么就还需要其他措施来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本。



#### 广播信道的数据链路层需要解决的问题

使用点对点信道的数据链路层，要解决三个基本问题；但是如果是广播信道的数据链路层，那还要解决一些更多的问题。

1，编址问题，判断广播中收到的帧是不是发给自己的：

![image-20220125165020219](computer_network_hnust.assets/image-20220125165020219.png)

- 在帧头会写入“目的地址和源地址”

2，共享式局域网中传输信号碰撞处理：

![image-20220125165311058](computer_network_hnust.assets/image-20220125165311058.png)

- 共享式局域网避免不了信号碰撞。
- 随着技术发展，交换技术的成熟和成本的降低，具有更高性能的，使用点对点链路和链路层交换机的“交换式局域网”，在有线（局域网）领域已经完全**取代**了共享式局域网。

3，交换式局域网图示：

![image-20220125165717973](computer_network_hnust.assets/image-20220125165717973.png)

4，无线局域网也使用共享信道技术，图示如下：

![image-20220125165816405](computer_network_hnust.assets/image-20220125165816405.png)

- CSMA/CA：载波监听，多点接入/碰撞避免。



### 封装成帧

#### 基本概念和术语

1，封装成帧：指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。

- 帧头和帧尾中包含有重要的控制信息。不同类型的帧的格式如下所示：

  <img src="computer_network_hnust.assets/image-20220125170328418.png" alt="image-20220125170328418" style="zoom:50%;" />

- 帧头和帧尾的作用之一就是**帧定界**，通过帧头和帧尾可以判断哪一段比特流是一个完整地帧：

  <img src="computer_network_hnust.assets/image-20220125170731707.png" alt="image-20220125170731707" style="zoom:50%;" />

- 并不是每一种数据链路层协议的帧都包含有帧定界标志，如MAC帧就没有：

  <img src="computer_network_hnust.assets/image-20220125171018567.png" alt="image-20220125171018567" style="zoom:50%;" />

  <img src="computer_network_hnust.assets/image-20220125171316297.png" alt="image-20220125171316297" style="zoom:50%;" />

  - 物理层为MAC帧添加的前导码中，“前同步码”使接收方的时钟同步；“帧开始定界符”表明其后面紧跟着的就是MAC帧。（个人理解标记MAC帧开始的前导码属于物理层内容，不属于帧本身，所以说MAC帧没有帧定界标志没错）
  - 以太网规定了帧间间隔时间为96bit的发送时间，因此mac帧并不需要帧结束定界符。



2，透明传输：指**数据链路层对上层交付的传输数据没有任何限制**，就好像数据链路层不存在一样。

- 如果不允许上层交付的传输数据中出现帧定界符的话，那么数据链路层就不是透明的，可用性也大大降低。所以数据链路层扫描上层交付的数据，进行“帧填充”，从而实现透明传输。

- 至于帧填充方式有以下两种：

  - 面向字节的物理链路使用**字节填充**(或称字符填充)的方法实现透明传输。

    - 数据链路层收到上层交付的内容后，会扫描内容，如果内容中出现帧的首尾定界符或者转义字符时，在该位置前加上转义字符，这样接收方就不会误以为帧结束了。

    - “转义字符”是一种特殊的控制字符，其长度为1字节，十进制值为27，而并不是“E，S，C”三个字符。

      <img src="computer_network_hnust.assets/image-20220125172649519.png" alt="image-20220125172649519" style="zoom:50%;" />

  - 面向比特的物理链路使用**比特填充**的方法实现透明传输。

    - 零比特填充的操作：可以“每五个连续的1后插入一个比特0”，保证上层交付的传输数据中不出现帧定界符（常为01111110）。接收方读取帧时，每五个1后的比特0剔除即可。

      <img src="computer_network_hnust.assets/image-20220125174937320.png" alt="image-20220125174937320" style="zoom:50%;" />

    - 例题：

      <img src="computer_network_hnust.assets/image-20220125173236808.png" alt="image-20220125173236808" style="zoom:50%;" />

3，为了提高帧的传输效率，应该使**帧的数据部分的长度尽可能大些**：

![image-20220125173443413](computer_network_hnust.assets/image-20220125173443413.png)

- 但是帧的数据部分不是越大越好。考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即**最大传送单元MTU**( Maximum Transfer Unit)。



### 差错检测

#### 概念定义

1，比特差错：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错: 1可能会变成0，而0也可能变成1。这称为**比特差错**。

2，误码率：在一段时间内，传输错误的比特占所传输比特总数的比率称为**误码率**BER(Bit Error Rate)。

3，差错检测码：使用**差错检测码**来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。

4，差错检测码图示：

![image-20220125195415696](computer_network_hnust.assets/image-20220125195415696.png)

- 帧接收方得知误码的方式：帧尾包含了一个长度为4字节的帧检验序列FCS字段，其作用就是让接收方的数据链路层检查帧在传输过程中是否产生了误码。



#### 奇偶校验

1，奇偶校验定义：在待发送的数据后面**添加1位奇偶校验位**，使整个数据（包括所添加的校验位在内)中**“1”的个数**为奇数(奇校验)或偶数（偶校验)。

2，奇校验图示：

![image-20220125200141665](computer_network_hnust.assets/image-20220125200141665.png)

- 如果有**奇数个位发生误码**，则奇偶性发生变化，**可以检查出误码**；如果有**偶数个位发生误码**，则奇偶性不发生变化（这是因为每个误码对奇偶性的影响相互抵消了），**不能检查出误码（漏检)**。
- 由于**奇偶校验**的漏检率比较高，因此计算机网络的**数据链路层一般不会采用**这种检测方式



#### 循环冗余校验

1，概念：

![image-20220125200336685](computer_network_hnust.assets/image-20220125200336685.png)

2，生成多项式举例说明：

![image-20220125200437614](computer_network_hnust.assets/image-20220125200437614.png)

3，实战例子：

![image-20220125200751138](computer_network_hnust.assets/image-20220125200751138.png)

- 异或：相异得1，相同得0



4，实战例子2：

![image-20220125200823358](computer_network_hnust.assets/image-20220125200823358.png)



#### 检错VS纠正

1，需要说明的是，**检错码**只能检测出帧在传输过程中出现了差错，但并不能定位错误，因此**无法纠正错误**。

2，要想纠正传输中的差错，可以使用冗余信息更多的**纠错码**进行**前向纠错**。但纠错码的开销比较大，在**计算机网络中较少使用**。

3，循环冗余校验**CRC**有很好的检错能力（**漏检率非常低**)，虽然计算比较复杂，但非常**易于用硬件实现**，因此被**广泛应用于数据链路层**。

4，在计算机网络中通常采用我们后续课程中将要讨论的**检错重传方式来纠正传输中的差错**，**或者仅仅是丢弃检测到差错的帧**，这取决于数据链路层向其上层提供的是**可靠**传输服务还是**不可靠**传输服务。



### 可靠传输

#### 可靠传输的基本概念

1，使用**差错检测技术**（例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了**误码**（比特错误)。

2，数据链路层向上层提供的服务类型

- **不可靠**传输服务:**仅仅丢弃有误码的帧**，其他什么也不做;
- **可靠**传输服务:想办法实现**发送端发送什么，接收端就收到什么**。

3，有线链路和无线链路对可靠传输的要求一般不同：

- 一般情况下，**有线链路**的误码率比较低，为了减小开销，并**不要求数据链路层**向上提供**可靠**传输服务。即使出现了误码，可靠传输的问题由其上层处理。

- **无线链路**易受干扰，误码率比较高，因此**要求数据链路层**必须向上层提供**可靠**传输服务。

4，**比特差错**只是传输差错的一种，从整个计算机网络体系结构来看，传输差错还包括**分组丢失**、**分组失序**以及**分组重复**。

- 词语说明：
  - 比特差错：传输数据的比特流出现差错
  - 分组丢失：如因路由器存储空间不足，路由器把分组丢弃导致分组丢失
  - 分组失序：由于网络传输原因，发送方发送分组的顺序，和接收方接收到分组的顺序不一致
  - 分组重复：由于网络原因，原发送分组在某一位置卡住，在发送方重发分组后，原分组又来到接收方，造成分组重复。

- 请注意，此处我们将帧的称呼改为了分组，这意味着传输差错不仅仅局限于数据链路层的比特差错。

- 分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。

- **可靠传输服务并不仅局限于数据链路层**，其他各层均可选择实现可靠传输。各层选择是否可靠传输的图示如下：

  <img src="computer_network_hnust.assets/image-20220125230633057.png" alt="image-20220125230633057" style="zoom:50%;" />

5，可靠传输的实现比较复杂，开销比较大，是否实现可靠传输取决于应用需求。



#### 可靠传输的实现机制

1，有三种可靠传输协议

![image-20220125230835029](computer_network_hnust.assets/image-20220125230835029.png)

- 这三种**可靠传输实现机制**的基本原理并**不仅限于数据链路层**,可以应用到计算机网络体系结构的各层协议中。
- 希望同学们在学习时,不要把思维局限在数据链路层,而应放眼于整个网络体系结构。



#### 可靠传输的实现机制之停止-等待协议

停止-等待协议SW（Stop-and-Wait）

1.1，简单情况下：

![image-20220125232034943](computer_network_hnust.assets/image-20220125232034943.png)

- 分组收发双方基于互联网通信，而不是局限在一条点对点的数据链路。
- 发送方没发送完一个数据分组后，并不能立刻将该数据分组从缓存中删除；只有在收到该数据分组的确认分组后，才能将其从缓存中删除。
- 发送方每发送完一个数据分组后，就暂不发送下一个数据分组，等待来自接收方的确认分组（ACK）或否认分组（NAK）：
  - 若收到确认分组，则可继续发送下一个分组
  - 若收到否认分组，则重发之前发送的那个数据分组

- 这样就实现了发送方发送什么，接收方接收什么。但是实际情况远比我们想象的复杂得多。



1.2，接收方没收到发送数据的情况。在发送方设置时钟来**超时重传**解决这个问题：

![image-20220125232414608](computer_network_hnust.assets/image-20220125232414608.png)

1.3，ACK丢失导致同一数据两次到达接收方。通过**对数据分组进行编号**来解决这个问题：

![image-20220125232747981](computer_network_hnust.assets/image-20220125232747981.png)![image-20220125232808629](computer_network_hnust.assets/image-20220125232808629.png)

1.4，ACK延误导致的ACK指向数据不清的问题。通过ACK编号来解决：

![image-20220125233220024](computer_network_hnust.assets/image-20220125233220024.png)

- 请注意，最下面的Data0和最上面的Data0不是同一data分组，这里是用0和1来区分不同的分组。
- 需要说明的是，对于数据链路层的点对点信道，往返时间比较固定，不会出现确认迟到的情况；因此若只在数据链路层上实现SW，可以不用给确认分组编号。



2，停止等待协议的注意事项：

![image-20220125234822019](computer_network_hnust.assets/image-20220125234822019.png)



3.1，停止等待协议的信道利用率

![image-20220126000258601](computer_network_hnust.assets/image-20220126000258601.png)

- 参数解释：

  - TD：发送方发送数据分组所耗费的发送时延TD。

  - RTT：收发双方之间的往返时间RTT

  - TA：接收方发送确认分组所耗费的发送时延TA。

  - 图中忽略了接收方对数据分组的处理时延，以发送方对确认分组的处理时延。

- 公式分析
  - TD+RTT+TA是停止等待协议的发送方，从发送一个数据分组开始，到可以发送下一个分组为止，所经历的总时间。
  - 因为仅仅是在TD内，才用来传送有用的数据，也就是数据分组。
  - TA一般都远小于TD，可以忽略。
  - 当RTT远大于TD时，信道利用率会很低，



3.2，停止等待协议实例：

![image-20220126000614597](computer_network_hnust.assets/image-20220126000614597.png)



3.3，停止等待协议实例2：

![image-20220126000747073](computer_network_hnust.assets/image-20220126000747073.png)

4，像停止-等待协议这种通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ（Automatic Repeat Request）；意思是重传的请求是自动进行的，因为不需要接受方显式得请求发送方重传某个出错的分组。

5，停止-等待协议的信道利用率很低若出现超时重传,则信道利用率更低。采用流水线传输可提高信道利用率，这就引入了“回退N帧协议GBN”：

![image-20220126113737211](computer_network_hnust.assets\image-20220126113737211.png)



#### 可靠传输的实现机制之回退N帧协议

回退N帧协议GBN(Go-Back-N)



1，回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数，是一种连续ARQ协议；在协议的工作过程中发送窗口和接收窗回不断向前滑动,因此这类协议又称为滑动窗回协议；由于回退N帧协议的特性,当通信线路质量不好时,其信道利用率并不比停止-等待协议高。



2，最简单的无差错情况：

- 采用3个bit给分组编序号，即序号是0~7。因为2的3次方为8，所以共有8个序号可用；但是一次不会传输8个序号，而是传输WT宽度个序号。
- 如果WT的值取1，则是停止-等待协议；若WT的值超过取值范围的上限，则会造成严重的后果。
- 接收窗口的尺寸WR取值为：WR=1；这一点“回退N帧协议”和“停止-等待协议”是相同的。

发送窗口宽度为5，接收窗口宽度为1，发送数据给接收方：

![image-20220126120016378](computer_network_hnust.assets\image-20220126120016378.png)

接收方接收数据，数据都无误的话，给每个分组都返回ACK，并且每发送一个ACK接收窗口就移动一个位置（位置宽度为分组的宽度）：

![image-20220126120034013](computer_network_hnust.assets\image-20220126120034013.png)

发送方每接收到一个ACK，发送穿哪个口就向前滑动一个位置（这里位置宽度为一个组），发送方可以把收到确认的数据分组从缓存中删除了；而接收方可以择机将已接收的数据分组交付上层处理：

![image-20220126120408686](computer_network_hnust.assets\image-20220126120408686.png)



3，累计确认的概念：

- 接收方**不一定**要对收到的数据分组**逐个发送确认**，而是可以在收到几个数据分组后(由具体实现决定)，**对按序到达的最后一个数据分组发送确认**。ACKn表示序号为n及以前的所有数据分组都已正确接收。
- 累计确认优点：
  - 即使确认分组丢失,发送方也可能不必重传!如本例ACK1丢失了，但并未造成1号数据分组的超时重传。
  - 可以减小接收方的开销，减少对网络资源的占用。因为需要发送的ACK的数目变小了。
- 累计确认缺点：
  - 不能向发送方及时反映出接收方已经正确接收的数据分组信息。因为就算正确接收了，也要等一等，等累计确认。

发送方将发送窗口内的0~4号数据分组依次连续发送出去，经过互联网的传输正确到达了发送方：

![image-20220126121140917](computer_network_hnust.assets\image-20220126121140917.png)

接收方当接收到0~1号分组后，给发送方发送累计确认ACK1；当又接收到2~4号分组后，发送累计确认ACK4：

![image-20220126121257081](computer_network_hnust.assets\image-20220126121257081.png)

假设ACK1在传输过程中丢失了，而ACK4正确到达了发送方；发送方接收ACK4后就知道了“发送窗口内，序号为4及以前的数据分组都已被接收方正确接收了”，于是将发送窗口向前移动五个位置，这样就有新的序号落入了发送窗口；发送方可以将收到确认的数据分组从换缓存中删除了，而且接收方可以择机将已接收的数据分组交付上层处理：

![image-20220126121736244](computer_network_hnust.assets\image-20220126121736244.png)



4，出现差错的情况，体现“回退N帧”：

发送方将落在发送窗口内的五个分组，依次连续发送出去，经过互联网给的传输到达了接收方：

![image-20220126122536750](computer_network_hnust.assets\image-20220126122536750.png)

假设五个分组在发送过程中收到干扰，其中五号数据分组出现了误码，接收方通过数据分组中的检错码发现了误码，于是丢弃该数据分组：

![image-20220126122703763](computer_network_hnust.assets\image-20220126122703763.png)

而后续到达的6701四个序号的数据分组与接收窗口中的序号不匹配，接收方同样也不能接收他们，将他们丢弃；并对之前按序接收的最后一个数据分组4进行确认，每因为序号不对丢弃一个数据分组，就发送一个ACK4：

![image-20220126122917229](computer_network_hnust.assets\image-20220126122917229.png)

![image-20220126122934395](computer_network_hnust.assets\image-20220126122934395.png)

4个ACK4经过互联网传输南湖到达发送方；发送方之前就接收过ACK4，当收到重复的ACK4时就知道了之前发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，至于收到几个重复确认就立刻重传,由具体实现决定；在本例中，假设收到这4个重复的确认并不会触发发送方立即重传，一段时间后超时计时器出现超时，发送方将发送窗口内已发送过的这些数据分组全部重传：

![image-20220126123535772](computer_network_hnust.assets\image-20220126123535772.png)

在本例中。尽管序号为6.7.0.1的数据分组正确到达接收方。但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受。发送方还要重传这些数据分组,**这就是所谓的Go-back-N(回退N帧)**。可见当通信线路质量不好时,回退N帧协议的信道利用率并不比停止-等待协议高。



5，查看发送窗口宽度超过取值的上限会怎样：

我们故意超过上限7，让发送窗口的长度WT为8；发送方将8个分组依次发送出去，他们经过互联网传输来到接收方：

![image-20220126134755587](computer_network_hnust.assets\image-20220126134755587.png)



接收方按序接收8个分组后，给发送方发回累计确认ACK7：

![image-20220126134913189](computer_network_hnust.assets\image-20220126134913189.png)

假设ACK7，在传输过程中丢失了，将导致发送方的超时重传；重传的0~7号数据分组到达接收方：

![image-20220126135024695](computer_network_hnust.assets\image-20220126135024695.png)

现在问题来了，接收方根据当前接收窗口内的序号，会对这8个数据分组按序接收；但是接收方之前已经接收过这8个数据分组了，现在是在重复接收；也就是说，接收方无法分辨新旧分组，进而会产生**分组重复**这种传输差错：

![image-20220126135301854](computer_network_hnust.assets\image-20220126135301854.png)

因此，发送窗口的尺寸不能超过其上限。



6，对回退N帧协议的工作原理做一个小结：

![image-20220126135435993](computer_network_hnust.assets\image-20220126135435993.png)



7，回退N帧协议的练习：

![image-20220126135819442](computer_network_hnust.assets\image-20220126135819442.png)



#### 可靠传输的实现机制之选择重传协议

选择重传协议SR(Selective Request)



1，选择重传协议是对回退N帧协议的改进：

- **回退N帧协议**的接收窗口尺寸**WR只能等于1**，因此**接收方只能按序接收正确到达的数据分组**。
- 一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而**丢弃（尽管它们无乱序和误码)**。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大**浪费**。
- 为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸**WR不应再等于1(而应大于1)**，以便**接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组**，等到所缺分组收齐后再一并送交上层。这就是**选择重传协议**。
- `注意`:**选择重传协议**为了使发送方仅重传出现差错的分组，接收方**不能再采用累积确认**，而需要对每个正确接收到的数据分组进行**逐一确认**!



2，选择重传协议讲解：

选择重传协议的**参数定义**如下：

![image-20220126140642619](computer_network_hnust.assets\image-20220126140642619.png)

发送方将序号落在发送窗口肉的这4个数据分组依次连续发送出去，它们经过联网的传输陆续到达接收方，但其中的2号数据分组丢失了：

![image-20220126140916536](computer_network_hnust.assets\image-20220126140916536.png)

只要序号落入接收窗口内且无误码的数据分组，接收方都会接收；接收方接收0号和1号数据分组，并发送0号和1号确认分组，接收窗口向前滑动两个位置，这样就有4和5这两个新的序号落入接收窗口：

![image-20220126141053310](computer_network_hnust.assets\image-20220126141053310.png)

接收方接收3号确认分组，并发送3号确认分组，但是接收窗口不能向前滑动，因为三号数据分组是未按序到达的数据分组：

![image-20220126141320171](computer_network_hnust.assets\image-20220126141320171.png)

这些确认分组经过互联网的传输陆续到达发送方，发送方每按序收到一个确认分组，发送窗口就向前滑动一个位置；发送方接收0号和1号确认分组，发送窗口向前滑动两个位置，这样就有4和5这两个新的序号落入发送窗口：

![image-20220126141607074](computer_network_hnust.assets\image-20220126141607074.png)

发送方将序号落入发送窗口的4号和5号数据分组发送出去，发送方现在可以将已经收到确认的0号和1号数据分组从发送缓存中删除了；而接收方可择机将已按序接收的0号和1号数据分组交付上层使用：

![image-20220126141953446](computer_network_hnust.assets\image-20220126141953446.png)

发送方接收3号确认分组；但发送窗口不能向前滑动，因为这是一个未按序到达的确认分组，发送方还没收到它之前的2号确认分组；不过需要记录3号数据分组已收到确认，这样该数据分组就不会超时重发：

![image-20220126144608099](computer_network_hnust.assets\image-20220126144608099.png)

四号和五号数据分组到达接收方，接收方接收它们，并发送4号和5号确认分组；但接收窗口不能向前滑动，因为4号和5号是未按序到达的数据分组，接收方还未收到他们之前的2号数据分组：

![image-20220126144913970](computer_network_hnust.assets\image-20220126144913970.png)

现在在4号和5号确认分组的传输过程中，发送方针对2号数据分组的重传计时器超时了，发送方重传2号数据分组；

![image-20220126145220901](computer_network_hnust.assets\image-20220126145220901.png)

4号和5号分组陆续到达发送方；发送方接收他们，但发送窗口不能向前滑动，因为他们是未按序到达的确认分组，发送方还未收到他们之前的2号确认分组；不过需要记录4号和5号数据分组已收到确认，这样他们就不会超时重发：

![image-20220126145455595](computer_network_hnust.assets\image-20220126145455595.png)

发送方之前重传的2号数据分组到达接收方，接收方接收该数据分组，并发送2号确认分组；接收窗口现在可以往前滑动四个位置。这样就有6791这四个新的序号落入接收窗口：

![image-20220126145705302](computer_network_hnust.assets\image-20220126145705302.png)

2号确认分组经过互联网的传输到达发送方，发送方接收该确认分组；发送窗口现在可以向前滑动四个位置，这样就有6701这四个新的序号落入发送窗口；发送方现在就可以继续将这四个序号的数据分组依次发送出去了：

![image-20220126150214184](computer_network_hnust.assets\image-20220126150214184.png)

3，讨论一下选择重传协议的发送窗口和接收窗口的尺寸问题：

![image-20220126150412063](computer_network_hnust.assets\image-20220126150412063.png)



4，探讨发送窗口和接收窗口的尺寸超过了它们的取值范围会出现什么样的情况：

前提定为：

![image-20220126150555247](computer_network_hnust.assets\image-20220126150555247.png)

结果：

![image-20220126150745093](computer_network_hnust.assets\image-20220126150745093.png)

- ACKn丢失后，发送方重发数据分组时，接收方无法分辨新旧数据分组，出现分组重复这种传输差错。



5，对选择重传协议的工作原理小结：

![image-20220126151238727](computer_network_hnust.assets\image-20220126151238727.png)



6，小练习：

![image-20220126151420670](computer_network_hnust.assets\image-20220126151420670.png)



### 点对点协议PPP

 1，**点对点协议PPP**(Point-to-Point Protocol)是目前使用最广泛的点对点数据链路层协议：

![image-20220126160839685](computer_network_hnust.assets\image-20220126160839685.png)

- 图中个人用户计算机与ISP通信时，所使用的数据链路层协议通常就是PPP协议。这里需要说明的是，在1999年公布的在以太网上运行的PPP协议，即PPP over Ethernet（PPPoE），他使得ISP可以通过”DSL，电路调制解调器，以太网等快带接入技术“，以以太网接口的形式，为用户提供接入服务。
- 另外，点对点协议PPP，也广泛应用于广域网路由器之间的专用线路



2，PPP协议的构成：

![image-20220126162735244](computer_network_hnust.assets\image-20220126162735244.png)

3，PPP协议的帧格式：

![image-20220126163209616](computer_network_hnust.assets\image-20220126163209616.png)

4，PPP协议是如何解决透明传输问题的-面向字节：

![image-20220126163927285](computer_network_hnust.assets\image-20220126163927285.png)

5，PPP协议是如何解决透明传输问题的-面向比特·：

![image-20220126164207485](computer_network_hnust.assets\image-20220126164207485.png)



6，PPP协议如何进行差错检测：

![image-20220126164735297](computer_network_hnust.assets\image-20220126164735297.png)

7，PPP协议工作状态：

![image-20220126165115049](computer_network_hnust.assets\image-20220126165115049.png)



### 媒体接入控制

#### 媒体接入控制的基本概念

1，共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即**媒体接入控制MAC**(Medium Access Control)。

![image-20220126165948278](computer_network_hnust.assets\image-20220126165948278.png)

2，媒体接入控制MAC分类：

![image-20220126170243937](computer_network_hnust.assets\image-20220126170243937.png)

- 需要注意的是：随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的**交换式局域网**在**有线领域**已完全**取代了共享式局域网**；但由于**无线信道**的广播天性，无线局域网仍然使用的是**共享媒体技术**。



#### 媒体接入控制之-静态划分信道

1，信道复用概念：

![image-20220126171222961](computer_network_hnust.assets\image-20220126171222961.png)

- 复用(Multiplexing）是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。
- 当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。



2，常见的信道复用技术有：

![image-20220126171412395](computer_network_hnust.assets\image-20220126171412395.png)



3，频分复用FDM讲解：

![image-20220126171616080](computer_network_hnust.assets\image-20220126171616080.png)

- 各子信道之间需要留出隔离频带，以免造成子信道间的干扰。
- 频分复用的所有用户同时占用不同的频带资源并行通信。



4，时分复用TDM：

![image-20220126171913673](computer_network_hnust.assets\image-20220126171913673.png)

- 时复用技术将时间划分成了—段段等长的时分复用帧；每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙。

- 如图所示。每一个用户所与用的时隙是周期唯出现的；其周期就是时分复用帧的长度。
- 时分复用的所有用户在不同的时间占用同样的频带宽度。



5，波分复用WDM：

![image-20220126190326201](computer_network_hnust.assets\image-20220126190326201.png)

- 波分复用其实就是光的频分复用。
- 光信号传输一段距离后会衰减，因此对衰减了的光信号必须进行放大才能继续传输。



6，码分复用CDM：

![image-20220126190657949](computer_network_hnust.assets\image-20220126190657949.png)

![image-20220126190815439](computer_network_hnust.assets\image-20220126190815439.png)

![image-20220126190908179](computer_network_hnust.assets\image-20220126190908179.png)

- 与FDM和TDM不同，CDM的每一个用户可以**在同样的时间使用同样的频带进行通信**。
- 由于**各用户使用经过特殊挑选的不同码型**，因此各用户之间**不会造成干扰**。



#### 媒体接入控制-动态接入控制-随机接入-CSMA/CD协议

1，碰撞的产生

![image-20220126191301016](computer_network_hnust.assets\image-20220126191301016.png)

- 早期的共享式以太网采用“载波监听多址接入/碰撞检测(CSMA/CD)”协议来解决该问题。



2，CSMA/CD名词解释：

![image-20220126191848165](computer_network_hnust.assets\image-20220126191848165.png)

- 96比特时间是指发送96比特所耗费的时闻,也称为帧间最小间隔
- 载波监听CS作用是使接收方可以检测出一个帧的结束，同时也使得所有其他站点都能有机会平等竟争信道并发送帧。



3，CSMA/CD简易流程图：

![image-20220126192111379](computer_network_hnust.assets\image-20220126192111379.png)

4，争用期（碰撞窗口）：

![image-20220126192555916](computer_network_hnust.assets\image-20220126192555916.png)

- 由于波的传播时延，双方在很短时间内先后发送数据，且发送时没检测到对方在发送数据，从而引发碰撞。



5，最小帧长：

![image-20220126193747731](computer_network_hnust.assets\image-20220126193747731.png)

- 主机C检测到信道空闲96比特时间，发送帧；但实际上此时信道并不空闲，只是主机A发送完成了让主机C误以为信道空闲。



6，最大帧长：

![image-20220126194039473](computer_network_hnust.assets\image-20220126194039473.png)

- 以太网的帧长应该有其上限，不然过长时间的占用总线会影响总线上的其他主机的功能。
- 两种不同类型的帧的格式如图所示，通过规定最小和最大数据载荷，保证帧的在最小帧长和最大帧长之间。



7，退避时间的计算方法：

![image-20220126195110130](computer_network_hnust.assets\image-20220126195110130.png)



8，使用CSMA/CD协议的共享式以太网的信道利用率：

![image-20220126195523954](computer_network_hnust.assets\image-20220126195523954.png)



9，帧发送流程图：

![image-20220126195633118](computer_network_hnust.assets\image-20220126195633118.png)



10，帧接收流程图：

![image-20220126195742801](computer_network_hnust.assets\image-20220126195742801.png)

- 只有正确通过图中的三个检查，主机才能接受所收到的帧。



11，最后需要说明的是：

- CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。
- 现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议



#### 媒体接入控制-动态接入控制-随机接入-CSMA/CA协议

载波监听多址接入/碰撞避免 CSMA/CA(Carrier Sense Multiple Access/Collision Avoidance)



1，CSMA/CA在媒体接入控制中的位置：

![image-20220126205207275](computer_network_hnust.assets\image-20220126205207275.png)



2，无线局域网为什么不能用CSMA/CD?

![image-20220126205444540](computer_network_hnust.assets\image-20220126205444540.png)



3，隐蔽站问题：

![image-20220126205609676](computer_network_hnust.assets\image-20220126205609676.png)

- 无线局域网中会有“隐蔽站”问题，但是有限局域网中不会有。



4，802.11无线局域网介绍：

![image-20220126205935011](computer_network_hnust.assets\image-20220126205935011.png)



5，帧间间隔IFS

![image-20220126210120133](computer_network_hnust.assets\image-20220126210120133.png)



6，CSMA/CA的工作原理：源站为什么在检测到信道空闲后还要再等待一段时间DIFS?：

![image-20220126210853421](computer_network_hnust.assets\image-20220126210853421.png)

7，CSMA/CA的工作原理：目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧?

![image-20220126210929085](computer_network_hnust.assets\image-20220126210929085.png)

8，CSMA/CA的工作原理：信道由忙转为空闲且经过DIFS时间后,还要退避—段随机时间才能使用信道?

![image-20220126211437156](computer_network_hnust.assets\image-20220126211437156.png)



9，CSMA/CA协议的退避算法：

![image-20220126211643899](computer_network_hnust.assets\image-20220126211643899.png)



10，CSMA/CA协议的退避算法图示：

![image-20220126212906113](computer_network_hnust.assets\image-20220126212906113.png)



11，CSMA/CA协议的信道预约：

![image-20220126213630850](computer_network_hnust.assets\image-20220126213630850.png)

![image-20220126213725728](computer_network_hnust.assets\image-20220126213725728.png)



- 对信道预约往往是值得的。



12，CSMA/CA协议的虚拟载波监听机制：

![image-20220126214448510](computer_network_hnust.assets\image-20220126214448510.png)

- 尽管C收不到A发的RTS帧，但是C可以收到B发送给A的CTS帧；这样C就知道了信道将被占用多长时间，在这段时间内C都不会争用信道；也就是说，A给B发送数据帧时不会受到C的干扰。



13，小练习：

![image-20220126215005046](computer_network_hnust.assets\image-20220126215005046.png)

- 这里说错了，CDMA属于信道划分的MAC协议，也属于MAC协议

![image-20220126215214663](computer_network_hnust.assets\image-20220126215214663.png)

![image-20220126215329071](computer_network_hnust.assets\image-20220126215329071.png)



### MAC地址,IP地址,ARP协议

前言：

![image-20220127144118329](computer_network_hnust.assets/image-20220127144118329.png)

- 注意MAC地址，IP地址，ARP协议分别属于哪一层。



#### MAC地址

1，MAC地址基本概念：

- 当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址;

- 在每个主机发送的**帧中必须携带标识发送主机和接收主机的地址**。由于这类地址是用于媒体接入控制MAC(Media Access Control)，因此这类地址被称为**MAC地址**;

  - MAC地址一般被固化在网卡(网络适配器）的电可擦可编程只读存储器EEPROM中，因此MAC地址也
    被称为**硬件地址**;

  - MAC地址有时也被称为**物理地址**。**请注意:这并不意味着MAC地址属于网络体系结构中的物理层**!

    <img src="computer_network_hnust.assets/image-20220127144932702.png" alt="image-20220127144932702" style="zoom:50%;" />

- 一般情况下，用户主机会包含两个网络适配器:有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡)。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，**严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识**。



2，IEEE 802局域网的MAC地址格式：

![image-20220127145534367](computer_network_hnust.assets/image-20220127145534367.png)

- 自行随意分配的网络接口标识符称为EUI；对于48bit(6byte*8bit)的MAC地址，可称为EUI-48!
- 一个“X”是4bit，2的4次方表示16；所以一个“X”就是16进制的1位。



3，IEEE的官网可查看已分配的组织唯一标识符OUI：

![image-20220127150237463](computer_network_hnust.assets/image-20220127150237463.png)

- 可以看到什么OUI被分配给了什么公司



4，一共有四种类型的MAC地址，可以通过MAC地址的第一字节的第一第二位看出：

![image-20220127150724357](computer_network_hnust.assets/image-20220127150724357.png)

- 思考：您拥有几个全球管理单播MAC地址?EUI-48地址空间会耗尽吗?
  - <img src="computer_network_hnust.assets/image-20220127150806138.png" alt="image-20220127150806138" style="zoom:50%;" />
  - 对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年(直到2080)，但是鼓励采用EUI-64作为替代。



5，MAC地址的发送顺序：

![image-20220127151055475](computer_network_hnust.assets/image-20220127151055475.png)



6，单播MAC地址发送举例：

![image-20220127151503993](computer_network_hnust.assets/image-20220127151503993.png)

- `......`表示帧首部的其他字段+数据载荷+帧尾部。
- 网友问：“为啥一直在用总线型举例，现在总线型应该淘汰了吧”。网友答：“因为还没讲交换机，因为现在只考虑理想的数据链路，方便理解”
- 主机收到一个帧时，帧的目的MAC地址与本机MAC地址不一致的话，丢弃该帧。



7，广播MAC地址举例：

![image-20220127152238313](computer_network_hnust.assets/image-20220127152238313.png)

- 主机接收到的帧的目的MAC地址是广播地址，则知道收到的帧是广播帧，则接受该帧



8，多播MAC地址举例：

![image-20220127153717955](computer_network_hnust.assets/image-20220127153717955.png)

- 图片说明：

  - MAC地址第一位的十六进制数不能整除2(1,3,5,7.9,B,D, F)，即为多播地址。

  - 网友问：“多播和广播有什么区别”。网友答：“广播是全部，多播是一个以上”。

  - 假设本图主机BCD支持MAC多播，根据各用户给自己的主机配置的多播组列表可以看出，主机B和主机C属于两个多播组，主机D不属于任何多播组。

- 步骤：

  1. 主机A构建多播帧时，在帧首部中的目的地址字段填入该多播MAC地址，源地址字段填入自己的MAC地址；再加上帧首部的其他字段，数据载荷，以及帧尾部，就构成了一个多播帧。主机A将该多播帧发送出去。
  2. 主机BCD都会收到该多播帧。主机B发现该多播帧的目的MAC地址在自己的多播组列表中，主机C发现该多播帧的目的MAC地址在自己的多播组列表中，因此主机B和C都会接受该帧并送交上层处理；而主机D发下该多播帧的目的地址不在自己的多播组列表中，主机D丢弃该多播帧。

- 给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址，具体可在图中网址查询。



9，随机MAC地址：

![image-20220127153908362](computer_network_hnust.assets/image-20220127153908362.png)

- 扫描网络时采用随机MAC地址技术



#### IP地址

1，需要说明的是，**IP地址属于网络层**的范畴，而非数据链路层的范畴；之所以在数据链路层这一章节的讲解中引入IP地址，是因为在我们日常的大多数网络应用中，属于数据链路层的MAC地址和属于网络层的IP地址都在使用，他们之间存在一定的关系去；IP地址的相关内容比较多，比如“分类的IP地址，划分子网的IP地址”等，这些内容将在网络层这一章详细介绍；本节课我们主要介绍IP地址的作用。



2，IP地址的组成和必要性：

![image-20220127160229730](computer_network_hnust.assets/image-20220127160229730.png)

- 网络N8中有两个主机，分配了两个IP地址“192.168.0.1”“192.168.0.2”；给路由器R4连接网络N8的接口也分配了一个IP地址“192.168.0.254”。
  - 这三个IP地址的前三个十进制数是相同的，也就是网络N8的编号。
  - 而最后一个十进制数各不相同，是网络N8上各主机和路由器接口的编号。
  - 换句话说，同一个网络上的各主机和路由器的各接口的IP地址的网络号部分应该相同（俗称网段），而主机号部分应互不相同。

- 因特网中不同网络的网络编号必须各不相同；例如在本例中，网络N8的编号为“192.168.0”，而网络N9的编号为“192.168.1”。
- 需要注意的是，在一个IP地址中，哪部分是网络编号，哪部分是主机编号，并不都和本例相同；将在后续网络层这一章详细讲解。



3，从网络体系结构看IP地址和MAC地址：

![image-20220127161620691](computer_network_hnust.assets/image-20220127161620691.png)

- 网络体系结构中，各层都**看不懂也无需看懂**上一层交付的数据，仅仅为数据加上自己层的头部和尾部再往下交付即可。

- 网络层首部中应封装有源IP地址和目的IP地址；数据链路层首部中应该封装有源MAC地址和目的MAC地址



4，数据包转发过程中，IP地址和MAC地址的变化情况：

![image-20220127162551698](computer_network_hnust.assets/image-20220127162551698.png)

- 为了方便起见，图中各主机和路由器各接口的“IP地址和MAC地址”用较为简单的标识符来表示，而并未使用实际的IP地址和MAC地址。
- 假设主机H1要给主机H2发送一个数据包，我们从网络体系结构的角度，来看看数据包在传输过程中IP地址和MAC地址的变化情况。
- 需要注意的是，主机中有完整的网络体系结构，而路由器的最高层为网络层(没有网络体系结构中的运输层和应用层)。

- 我们所关注的重点是：网络层封装IP数据报时，源IP地址和目的IP地址应该填写什么；数据链路层封装帧时，源MAC地址和目的MAC地址应填写什么。因此，我们忽略网络体系结构中，除网络层和数据链路层外的其他各层；可以想象成各网络层进行水平方向的逻辑通信，各数据链路层进行水平方向的逻辑通信。

步骤如下：

1. 主机H1将数据包发送给路由器R1

   <img src="computer_network_hnust.assets/image-20220127163441486.png" alt="image-20220127163441486" style="zoom:50%;" />

2. 路由器R1将收到的数据包转发给路由器R2

   <img src="computer_network_hnust.assets/image-20220127163611398.png" alt="image-20220127163611398" style="zoom:50%;" />

3. 路由器R2将收到的数据包转发给H2

   <img src="computer_network_hnust.assets/image-20220127163727649.png" alt="image-20220127163727649" style="zoom:50%;" />

本例可以看出：

- 数据包转发过程中，**源IP地址和目的IP地址始终保持不变；而源MAC地址和目的MAC地址逐个链路或逐个网络改变**。

- H1知道R1的IP地址是设置了默认网关，路由器之间是通过路由协议相互通信才知道相连接路由的IP地址。其他的自然不知道



5，主机知道“把数据包传给哪个相邻传输节点+该相邻节点的ip”，但是不知道该相邻传输节点的MAC地址；通过IP地址获得MAC地址需要ARP协议：

![image-20220127164349953](computer_network_hnust.assets/image-20220127164349953.png)



6，小练习：

![image-20220127164553700](computer_network_hnust.assets/image-20220127164553700.png)



#### ARP协议

1，ARP协议的功能：通过IP地址找到MAC地址。



2，ARP协议的工作原理

1. 主机B想给主机C发送数据；但是主机B知道主机C的ip地址，不知道主机C的MAC地址：

   <img src="computer_network_hnust.assets/image-20220127171027951.png" alt="image-20220127171027951" style="zoom:50%;" />

2. 主机B会在自己的ARP高速缓存表中查询“主机C的IP地址对应的MAC地址”，没找到：

   <img src="computer_network_hnust.assets/image-20220127171510136.png" alt="image-20220127171510136" style="zoom:50%;" />

   - 每台主机都有一个ARP高速缓存表，ARP高速缓存表中记录有IP地址和MAC地址的对应关系。

3. 主机B创建ARP请求报文，来获取主机C的MAC地址：

   <img src="computer_network_hnust.assets/image-20220127171806693.png" alt="image-20220127171806693" style="zoom:50%;" />

   - ARP请求报文封装在MAC帧中，目的地址为FF-FF-FF-FF-FF-FF(广播地址)

4. 主机B发送封装有ARP请求报文的广播帧，以太网总线上的其他主机都能收到该广播帧；主机A的网卡收到该广播帧后，将其送交上层处理，上层的ARP进程解析ARP请求报文，发现所询问的IP地址不是自己的IP地址，因此不予理会：

   <img src="computer_network_hnust.assets/image-20220127172247873.png" alt="image-20220127172247873" style="zoom:50%;" />

5. 主机C的网卡收到该广播帧后，将其送交上层处理，上层的ARP进程解析ARP请求报文，发现所询问的IP地址正是自己的IP地址，需要进行相应。主机C**首先**将B的IP地址与MAC地址记录到自己的ARP高速缓存表中;**然后**给B发送ARP响应，以告知自己的MAC地址。ARP响应报文是：

   <img src="computer_network_hnust.assets/image-20220127172521733.png" alt="image-20220127172521733" style="zoom: 50%;" />

   - 注意：ARP相应报文是封装在MAC帧中的，目的地址为目标主机的MAC地址(不再是广播)。

6. 主机C给主机B发送封装有ARP相应报文的单播帧，总线上的其他主机都能收到该单播帧；主机A的网卡收到该单播帧后，发现其目的MAC地址与自己的MAC地址不匹配，直接丢弃该帧：

   <img src="computer_network_hnust.assets/image-20220127173328676.png" alt="image-20220127173328676" style="zoom:50%;" />

   

7. 主机B的网卡收到该单播帧后，发现其目的MAC地址就是自己的MAC地址，将其交付上层处理；上层的ARP进程解析ARP响应报文，将其所包含的主机C的IP地址与MAC地址记录到自己的ARP高速缓存表中。

   <img src="computer_network_hnust.assets/image-20220127173222907.png" alt="image-20220127173222907" style="zoom:50%;" />

8. 主机B现在可以给主机C发送之前想发送的数据包了。



3，ARP高速缓存表中每一条记录都有其类型，类型分为“动态和静态”两种：

![image-20220127173632163](computer_network_hnust.assets/image-20220127173632163.png)

- 动态原因：IP地址和MAC地址的对应关系不是永久性的；如当主机的网卡坏了，更换新的网卡后，主机的IP地址没变，但是主机的MAC地址改变了。



4，思考：主机H1是否可以使用ARP协议获取到主机H2的MAC地址？

![image-20220127173915874](computer_network_hnust.assets/image-20220127173915874.png)

- 答案是否定的，ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用。
- 对于本例，ARP协议的使用是**逐段链路进行**的



5，需要说明的是：

- 除ARP请求和响应外，ARP还有其他类型的报文（例如用于检查IP地址冲突的“无故ARP、或称为免费ARP(Gratuitous ARP)”) ;
- ARP没有安全验证机制。存在ARP散骗(攻击)问题。



### 集线器与交换机的区别

#### 集线器

1，早期的使用无源电缆和大量机械接头的总线型以太网，并不像人们想象的那么可靠；被淘汰：

![image-20220127192430142](computer_network_hnust.assets/image-20220127192430142.png)

2，使用双绞线和集线器HUB的星型以太网：

![image-20220127193035774](computer_network_hnust.assets/image-20220127193035774.png)

- 实践证明，使用双绞线+集线器，比使用具有大量机械接头的无源电缆要可靠的多；并且价格便宜，使用方便。因此粗缆和细缆以太网早已成为了历史。
- 在分析问题时，我们可将集线器简单看作一条总线。
- 放大器和集线器都是物理层设备



3，使用集线器HUB在物理层扩展以太网：

![image-20220127193805142](computer_network_hnust.assets/image-20220127193805142.png)

![image-20220127193939213](computer_network_hnust.assets/image-20220127193939213.png)

- 由于集线器只工作在物理层，所以更具体的说法是“使用集线器在物理层扩展以太网”。
- 假设某学院有三个系部，每个系部都有一个使用集线器作为互莲设备的以太网；这三个以太网相互独立，各自共享自己的总线资源，是三个独立的碰撞域。
  - 比如，一系中的某台主机，给另一台主机发送数据帧，由于总线特性，表示该数据帧的信号会传输到一系中的其他各主机。
  - 二系中的多台主机同时发送数据帧，由于总线特性，这必然会产生信号碰撞，碰撞后的信号会传输到二系中的各主机。

- 为了使各系部的以太网能相互通信，可再使用一个集线器将他们互联起来；这样，原来三个独立的以太网就互联成为一个更大的以太网，原来三个碰撞域合并成为一个更大的碰撞域。换句话说，就是形成了一个更大的总线型以太网。



#### 交换机

1，在集线器之后，发展出了**更先进**的网络互联设备，也就是以太网交换机。



2，从典型例子看以太网交换机与集线器的区别：

![image-20220127194827403](computer_network_hnust.assets/image-20220127194827403.png)

- 使用集线器互连而成的共享总线式以太网上的某个主机要给另一个主机发送单播帧：
  - 该单播帧会通过共享总线传输到总线上的其他各个主机
- 使用交换机互连而成的交换式以太网上的某个主机要给另一个主机发送单播帧：
  - 该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，而不是网络中的其他各个主机。
- 很显然，交换机具有明显的优势。需要说明的是，为了简单起见，本节课所有举例的前提条件是：
  - 忽略ARP过程
  - 假设交换机的帧交换表已“学习好了”



3，以太网交换机工作原理：

![image-20220127195759124](computer_network_hnust.assets/image-20220127195759124.png)

- 全双工意思是：发送帧和接收帧可以同时进行。

- 注意:使用集线器的以太网在逻辑上是共享总线的,需要使用CSMA/CD协议来协凋各主机争用总线，只能工作在半双工模式，也就是收发帧不能同时进行。
- 以太网交换机查找帧的目的MAC地址所对应的接口号，往该接口号转发帧。这体现交换机会记录MAC地址的。



4，集线器对比交换机-主机发送单播帧时：

![image-20220127201804080](computer_network_hnust.assets/image-20220127201804080.png)![image-20220127201812494](computer_network_hnust.assets/image-20220127201812494.png)

- 对于使用集线器的共享总线型以太网，单播帧会传播到总线上的其他各主机；各主机中的网卡根据帧的目的MAC地址决定是否接受该帧。
- 对于使用交换机的交换式以太网，交换机收到单播帧后，根据帧的目的MAC地址和自身的帧交换表，将帧转发给目的主机，而不是网络中的其他所有主机。



5，集线器对比交换机-主机发送广播帧时：

![image-20220127202418954](computer_network_hnust.assets/image-20220127202418954.png)![image-20220127202427166](computer_network_hnust.assets/image-20220127202427166.png)

- 对于使用集线器的共享总线型以太网，广播帧会传播到总线上的其他各主机；各主机中的网卡检测到帧的目的MAC地址是广播地址，就接受该帧。
- 对于使用交换机的交换式以太网，交换机收到单播帧后，检测到帧的目的MAC地址是广播地址；于是从除该帧进入交换机接口外的其他各接口转发该帧；网络中除源主机外的其他各主机收到广播帧后，接受该广播帧。
- 从本例可以看出：使用集线器的共享总线型以太网中的各主机属于同一个广播域；而使用交换机的交换式以太网中的各主机，也属于同一个广播域。因此，对于广播帧的情况，从效果上看没有什么区别。



6，对比网络中的多台主机同时给另一台主机发送单播帧的情况：

![image-20220127202857638](computer_network_hnust.assets/image-20220127202857638.png)

![image-20220127202844027](computer_network_hnust.assets/image-20220127202844027.png)![image-20220127202648849](computer_network_hnust.assets/image-20220127202648849.png)

![image-20220127202922636](computer_network_hnust.assets/image-20220127202922636.png)![image-20220127202938117](computer_network_hnust.assets/image-20220127202938117.png)



- 对于使用集线器的共享总线型以太网，这必然会产生碰撞；遭遇碰撞的帧会传播到总线上的各主机。
- 对于使用交换机的交换式以太网，交换机收到多个帧时，会将他们缓存起来，然后逐个转发给目的主机，不会产生碰撞。



7，使用集线器扩展以太网对比使用交换机扩展以太网-发送单播帧：

![image-20220127203823070](computer_network_hnust.assets/image-20220127203823070.png)

- 仅使用集线器扩展以太网后，发送单播帧的情况如图所示；仅使用交换机扩展以太网后，发送单播帧的情况如图所示；
- 很显然，交换机具有非常明显的优势；交换机的控制下，单播帧仅被传给目的主机，而不是被传给众多无关主机。



8，使用集线器扩展以太网对比使用交换机扩展以太网-发送广播帧：

![image-20220127204421722](computer_network_hnust.assets/image-20220127204421722.png)

- 仅使用集线器扩展以太网后，发送广播帧的情况如图所示；仅使用交换机扩展以太网后，发送广播帧的情况如图所示；
- 从效果上看是一样的，可见不管使用集线器还是交换机来扩展以太网，扩展后的以太网中的各主机都属于同一个广播域。



9，使用集线器扩展以太网对比使用交换机扩展以太网-竞争总线碰撞例子：

![image-20220127204605131](computer_network_hnust.assets/image-20220127204605131.png)

- 仅使用集线器扩展的以太网，在逻辑上仍然是共享总线的，并且形成为一个更大的碰撞域；换句话说，参与竞争总线的主机比扩展前的更多了。
- 同样的传输任务，在仅使用交换机扩展的以太网上就不会产生碰撞。



10，如果仅仅使用集线器来扩展以太网，不仅会扩大广播域，还会扩大碰撞域；但是如果使用交换机将原来各自独立的碰撞域连接起来，只会扩大广播域，而不会扩大碰撞域。也就是说，**交换机可以隔离碰撞域**。

![image-20220127204746342](computer_network_hnust.assets/image-20220127204746342.png)



11，小结

![image-20220127205015511](computer_network_hnust.assets/image-20220127205015511.png)

- 需要说明的是，工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这使得集线器逐渐被市场淘汰；目前很难在市场上看到集线器了。
- 集线器在物理层；交换机在数据链路层；路由器在网络层



### 以太网交换机自学习和转发帧的流程

#### 基本概念

- 以太网交换机工作在数据链路层（也包括物理层)
- 以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。
- 以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表。



#### 以太网交换机自学习和转发帧的流程实例

- 如本图所示，相互连接的两台以太网交换机各自连接了三台主机，构成了一个交换式以太网。
- 为了简单起见，各主机中网卡上固化的MAC地址仅用一个大写字母表示，各主机互不相同。
- 为了将重点放在以太网交换机自学习，我们假设各主机已经知道了网络中其他各主机的MAC地址，换句话说，不需要首先通过ARP来获取目的主机的MAC地址。
  - 老师说了ARP协议的过程省略掉，实际上可以通过IP地址获得MAC地址

1，假设主机A给主机B发送帧，该帧从交换机1的接口1进入交换机；交换机1首先进行登记的工作，将该帧的源MAC地址A记录到自己的帧交换表中，并将该帧进入自己的接口的接口号1相应的也记录到帧交换表中。上述登记工作就称为交换机的自学习：

![image-20220127224653161](computer_network_hnust.assets/image-20220127224653161.png)

2，之后，交换机1对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B，找不到；于是对该帧进行盲目的转发，也称为泛洪，也就是从除该帧进入交换机接口外的其他所有接口转发该帧：

![image-20220127225355399](computer_network_hnust.assets/image-20220127225355399.png)

- 可以看出，交换机一开始还是比较“笨”的，它还没有足够的知识来明确转发帧，只能进行盲目的转发。



3，主机B的网卡收到该帧后，根据帧的目的MAC地址B，就知道这是发送给自己的帧，于是就接受该帧；主机C的网卡收到该帧后，根据帧的目的MAC地址B，就知道这不是发送给自己的帧，于是就丢弃该帧：

![image-20220127225644109](computer_network_hnust.assets/image-20220127225644109.png)



4，该帧从交换机2的接口2进入交换机2；交换机2首先进行登记的工作，将该帧的源MAC地址A记录到自己的帧交换表中，将该帧进入自己的接口的接口号2相应的也记录到帧的交换表中：

![image-20220127230322204](computer_network_hnust.assets/image-20220127230322204.png)



5，之后交换机2对该帧进行转发，该帧的目的MAC地址是B，在帧交换表中查找MAC地址B；找不到，于是对该帧进行盲目地转发；主机DEF都会收到该帧，根据帧的目的MAC地址B，就知道这不是发送给自己的帧，于是丢弃该帧：

![image-20220127230620844](computer_network_hnust.assets/image-20220127230620844.png)



6，接下来主机B给主机A发送帧，该帧从交换机1的接口3进入交换机1；交换机1首先进行登记工作，将该帧的源MAC地址B记录到自己的帧交换表中；将该帧进入自己的接口的接口号3相应得也记录到自己的帧交换表中；

![image-20220127231240360](computer_network_hnust.assets/image-20220127231240360.png)



7，之后交换机1对该帧进行转发；该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，于是按照MAC地址A所对应的接口号1从接口1转发该帧，这是明确的转发：

![image-20220127231651398](computer_network_hnust.assets/image-20220127231651398.png)



8，主机A的网卡收到该帧后，根据帧的目的MAC地址A就知道这是发送给自己的帧，于是接受该帧；很显然，交换机2不会收到该帧：

![image-20220127231958114](computer_network_hnust.assets/image-20220127231958114.png)



9，现在，主机E给主机A发送帧，该帧从交换机2的接口3进入交换机2；交换机2首先进行登记工作：

![image-20220127232409472](computer_network_hnust.assets/image-20220127232409472.png)



10，之后交换机2对该帧进行转发；该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到；于是按照MAC地址A所对应的接口号2从接口2转达该帧，这是明确的转发：

![image-20220127232653295](computer_network_hnust.assets/image-20220127232653295.png)



11，该帧从交换机1的接口4进入交换机1；交换机1首先进行登记的工作：

![image-20220127232824083](computer_network_hnust.assets/image-20220127232824083.png)



12，之后，交换机1对该帧进行转发；该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，于是按照MAC地址A所对应的接口号1从接口1转发该帧，这是明确的转发：

![image-20220127233354160](computer_network_hnust.assets/image-20220127233354160.png)



13，主机A的网卡收到该帧后，根据帧的目的MAC地址A，就知道这是发送给自己的帧，于是接受该帧：

![image-20220127233449042](computer_network_hnust.assets/image-20220127233449042.png)



14，再来看看以太网交换机丢弃帧的情况，为了演示该情况，我们给交换机1的接口在链接一台主机G；为了简单起见，没有画出集线器；这样主机A，主机G，交换机1的接口1就共享同一条总线：

![image-20220127233919898](computer_network_hnust.assets/image-20220127233919898.png)



15，假设主机G给主机A发送帧，该帧通过总线进行传输，主机A和交换机1的接口1都可以收到；主机A的网卡收到该帧后，据帧的MAC地址A就知道这是发送给自己的帧，于是接受该帧：

![image-20220127234111140](computer_network_hnust.assets/image-20220127234111140.png)



16，交换机1收到该帧后，首先进行登记工作：

![image-20220127234214900](computer_network_hnust.assets/image-20220127234214900.png)



17，之后交换机1对该帧进行转发，该帧的目的MAC地址是A，在帧交换表中查找MAC地址A，可以找到，MAC地址A所对应的接口号是1；但是该帧正是从接口1进入交换机1的，交换机1不会在从该接口将该帧转发出去，因为这是没有必要的，于是**丢弃该帧**；很显然，交换机2不会收到该帧：

![image-20220127234443446](computer_network_hnust.assets/image-20220127234443446.png)



18，随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址以及它们与自己各接口的对应关系

![image-20220127234726145](computer_network_hnust.assets/image-20220127234726145.png)



19，需要注意的是，帧交换表中的每一条记录都有自己的**有效时间**，到期自动删除。这是因为**MAC地址与交换机接口的对应关系不是永久性的**。

- 例如：交换机某接口所连接的主机更换成了另一台主机；又或者主机中的网卡坏了，更换了新的网卡。这些情况都会导致MAC地址与交换机接口的对应关系的改变。
- 类似的还有ARP高速缓存表，表中的IP地址与MAC地址的对应关系记录也是会定期自动删除的，这是因为IP地址与MAC地址的对应关系也并不是永久性的。



#### 习题

1，

![image-20220127235316178](computer_network_hnust.assets/image-20220127235316178.png)



### 以太网交换机的生成树协议STP

STP主要是网络工程师学的，这块可以了解即可。



1，冗余链路提高网络可靠性：

![image-20220128114459808](computer_network_hnust.assets/image-20220128114459808.png)

- 冗余链路会带来很多问题，所以引出“生成树协议STP”解决冗余链路带来的问题。



2，生成树协议内容：

![image-20220128114815077](computer_network_hnust.assets/image-20220128114815077.png)





### 虚拟局域网VLAN概述

#### 引入

1，交换式以太网规模扩大后引发的一些问题：

![image-20220128115706216](computer_network_hnust.assets/image-20220128115706216.png)

- 除非应用需求必须要使用广播，否则网络中的主机应尽量不使用广播！



2，网络中会频繁出现广播信息，因为有很多协议都可以广播：

![image-20220128115850079](computer_network_hnust.assets/image-20220128115850079.png)





3，使用路由器将较大的广播域分割成更小的广播域：

![image-20220128120225447](computer_network_hnust.assets/image-20220128120225447.png)

- 路由器工作在网络体系结构的第三层(网络层)
- 由于路由器默认情况下不对广播数据包进行转发，因此路由器很自然地就可以隔离广播域。
- 路由器缺点：
  - 成本较高，局域网内全部使用路由器来隔离广播域是不现实的
- 针对路由器的缺点，和隔离广播域的需求，虚拟局域网技术应运而生。



#### 虚拟局域网定义实例

1, 虚拟局域网VLAN(Virtual Local Area Network)是一种将局域网内的**设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。**



2，现在一楼二楼三楼分别有一个局域网，可以将他们用一个交换机互联成一个更大的局域网。那么原来每一个局域网成为现在这个局域网的一个网段，网络域中的各主机属于同一个广播域；某个主机发送的广播数据包其他所有主机都可以收到

![image-20220128120727713](computer_network_hnust.assets/image-20220128120727713.png)



3，根据应用需求，我们将该局域网划分成两个VLAN，分别为“VLAN1和VLAN2”：

![image-20220128121039931](computer_network_hnust.assets/image-20220128121039931.png)

- 此后，VLAN1中的广播数据包不会传送到VLAN2，VLAN2中的广播数据包也不会传送到VLAN1。也就是说，同一个VLAN内部可以广播通信，不同VLAN内部不能广播通信：



4，实现VLAN的方式在下一节讲解



### 虚拟局域网VLAN的实现机制

虚拟局域网技术是在交换机上实现的，需要交换机能够实现以下两大功能：

- 一个是能够处理带有VLAN标记的帧(IEEE 802.1Q帧)
- 另一个是交换机的各端口可以支持不同的端口类型；不同端口类型的端口对帧的处理方式有所不同

#### IEEE 802.1Q帧

1，IEEE 802.1Q帧介绍：

![image-20220128135045484](computer_network_hnust.assets/image-20220128135045484.png)





#### 交换机的端口类型

端口类型和缺省VLAN ID：

![image-20220128135246782](computer_network_hnust.assets/image-20220128135246782.png)

- 思科交换机没有hybrid端口。



#### ACCESS端口说明

![image-20220128140557617](computer_network_hnust.assets/image-20220128140557617.png)



#### ACCESS端口广播帧工作实例

1，我们的应用需求时将主机A和B划归到VLAN2，将主机C和D划归到VLAN3；这样VLAN2中的广播帧不会传送的VLAN3，VLAN3中的广播帧也不会传送到VLAN2。

![image-20220128140915459](computer_network_hnust.assets/image-20220128140915459.png)

- 为了实现这种应用，可以在交换机上创建VLAN2和VLAN3，然后将交换机的端口1和2划归到VLAN2，因此端口1和2的PVID值等于2；将交换机的端口3和4划归到VLAN3，因此端口3和4的PVID值等于3



2，我们来看主机A发送广播帧的情况，该帧从交换机的端口1进入交换机；由于端口1的类型时ACCESS，他会对接收到的“未打标签”的普通以太网MAC帧“打标签”，也就是插入4字节的VLAN标记字段；如本图所示，由于端口1的PVID值等于2，因此所插入的4宇节VLAN标记字段中的VID的值也等于2：

![image-20220128141356748](computer_network_hnust.assets/image-20220128141356748.png)

3，广播帧中的VID的取值与端口2的PVID的取值都等于2，因此交换机会从端口2对帧进行“去标签”转发：

![image-20220128141618534](computer_network_hnust.assets/image-20220128141618534.png)

4，VLAN3中主机发送广播帧后的步骤同理。



#### TRUNK端口介绍

![image-20220128141826351](computer_network_hnust.assets/image-20220128141826351.png)



#### TRUNK端口广播帧工作实例

1，假设主机A发送了一个广播帧，该帧从交换机1的端口1进入交换机；由于端口1的类型时ACCESS，他会对接收到的未打标签的普通以太网MAC帧“打标签”，也就是插入4字节的VLAN标记字段；由于端口1的PVID值等于1，因此，所插入的4字节VLAN标记字段中的VID的值也等于1：

![image-20220128142226024](computer_network_hnust.assets/image-20220128142226024.png)

2，该广播帧的VID的取值与端口2的PVID值都等于1，端口2的类型时ACCESS，因此交换机1会从端口2对帧进行“去标签”转发：

![image-20220128142837904](computer_network_hnust.assets/image-20220128142837904.png)

3，该广播帧中的VID的取值与端口5的PVID的值都等于1，端口5的类型是TRUNK，因此交换机1会从端口5对帧进行“去标签”转发

![image-20220128143058082](computer_network_hnust.assets/image-20220128143058082.png)



4，本例中，交换机2会对接收到的“未打标签”的普通以太网MAC帧“打标签”，也就是插入4自己的VLAN标记字段；由于端口5的PVID值等于1，因此所插入的4字节VLAN标记字段中的VID的值也等于1：

![image-20220128143253645](computer_network_hnust.assets/image-20220128143253645.png)

5，该广播帧中的VID的取值与端口1和2的PVID值都等于1；端口1和2的类型都是ACCESS，因此交换机2会从端口1和2对帧进行“去标签”的转发：

![image-20220128143536677](computer_network_hnust.assets/image-20220128143536677.png)

6，再来看主机C发送广播帧的情况，该帧从交换机1的端口3进入交换机；由于端口3的类型时ACCESS，他会对接收到的“未打标签”的普通以太网MAC帧打标签，也就是插入4字节的VLAN标记字段；由于端口3的PVID值等于2，因此所插入的4字节VLAN标记字段中的VID的值也等于2：

![image-20220128144729978](computer_network_hnust.assets/image-20220128144729978.png)

7，该广播帧中的vid的取值与端口4的PVID值都等于2，端口4的类型是ACCESS，因此交换机1会从端口4对帧进行“去标签“转发”：

![image-20220128144920767](computer_network_hnust.assets/image-20220128144920767.png)

8，该广播帧中的VID的取值与端口5的PVID值不相等，由于TRUNK端口VID不等于PVID的帧是直接转发的，因此交换机1会从端口5对帧直接转发，也就是不去掉标签而带着标签直接转发：

![image-20220128145141797](computer_network_hnust.assets/image-20220128145141797.png)

9，很显然，该802.1Q广播帧会从交换机2的端口5进入交换机2，Trunk端口接收已打标签的802.1Q帧：

![image-20220128145249906](computer_network_hnust.assets/image-20220128145249906.png)

10，该广播帧中的VID的取值与端口3和4的PVID值都等于2，端口3和4的类型都是ACCESS类型；因此交换机2会从端口3和4对帧进行“去标签”转发：

![image-20220128145443329](computer_network_hnust.assets/image-20220128145443329.png)



11，由本例可以看出，在由多个交换机互连而成的交换式以太网中划分VLAN时：

- 连接主机的交换机端口应设置为ACCESS类型。
- 交换机之间互联的端口应设置为TRUNK类型。

- 网友：“我悟了，就是贴标签撕标签”。



#### ACCESS+TRUNK端口例题

![image-20220128145837718](computer_network_hnust.assets/image-20220128145837718.png)

- 网友问：”为什么TRUNK端口对于标签相同的帧撕标签后再贴相同标签，而对于标签不同的帧直接转发；让TRUNK端口对所以帧不管标签直接转发的效果不是一样的吗？“。
  - 网友答：“看这个例子就懂了”



#### 华为交换机HYBRID端口

（简单了解即可）。

1，HYBRID端口概念：

![image-20220128145954301](computer_network_hnust.assets/image-20220128145954301.png)



2，实例图：

![image-20220128150352646](computer_network_hnust.assets/image-20220128150352646.png)

- 可以理解为 标签只在交换机内部时存在，出了交换机时，标签都去掉了，就变成了普通mac帧。所以普通计算机收到一定是普通的mac帧。出了交换机还带标签的帧会被丢弃



## 网络层

### 网络层概述

#### 为何需要网络层

1，网络层的主要任务是**实现网络互连**，进而**实现数据包在各网络之间的传输**。

![image-20220128162851997](computer_network_hnust.assets/image-20220128162851997.png)

- 如图所示，这些异构型网络如果只是需要各自内部通信，那他们只要实现各自的物理层和数据链路层即可。但是如果需要把这些异构型网络互联起来，形成一个更大的互联网，就需要使用网络层互联设备路由器。

  <img src="computer_network_hnust.assets/image-20220128163017677.png" alt="image-20220128163017677" style="zoom:50%;" />

- 需要说明的是，为了简单起见，有时我们可以不用画出这些网络，而将他们看作是一条链路即可

<img src="computer_network_hnust.assets/image-20220128163047918.png" alt="image-20220128163047918" style="zoom:50%;" />

2，对于互联网而言，仅实现计算机网络体系结构中的物理层和数据链路层，是不能实现数据包在互联网中各网络之间传输的；要实现该功能，就必须实现网络层。



#### 网络层需要解决的主要问题

1，第一个问题，网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”)？：

- 传输错误：
  - 数据包在传输过程中可能会出现误码；
  - 也有可能由于路由器繁忙而被路由器丢弃；
  - 还有可能出现按序发送的数据包不能按序到达接收方。
- 区分可靠不可靠：
  - 如果网络层对上述传输错误不采取任何措施，则提供的是不可靠传输服务；
  - 如果网络层对上述传输错误采取措施，并使得接收方能正确接收发送方所发送的数据包，则提供的是可靠传输服务。
- 不同网络体系结构所提供的服务可能是不同的，例如：
  - 因特网使用的TCP/IP协议体系的网际层，提供的是无连接的不可靠的数据报服务
  - 而ATM，帧中继和X.25的网络层提供的都是面向连接的可靠的虚电路服务



---



2，第二个问题，网络层寻址问题：

例如TCP/IP协议体系的网际层使用IP地址，举例说明

<img src="computer_network_hnust.assets/image-20220128164606019.png" alt="image-20220128164606019" style="zoom:50%;" />

网络N1上两个路由器接口各自所分配的IP地址为“192.168.0.1和192.168.0.2”；他们的前三个数是相同的，可以看做他们所在网络的网络编号；而第四个数各不相同，用于区分这两个不同的路由器接口。网络N3上两个路由器接口各自所分配的IP地址为“172.16.0.1和172.16.6.16”；他们的前两个数是相同的，可以看做他们所在网络的网络编号；而后两个数各不相同，用于区分这两个不同的路由器接口。网络N7上两个路由器接口各自所分配的IP地址为“10.1.2.3“和10.6.7.8”；他们的第一个数是相同的，可以看做他们所在网络的网络编号；而后三个数各不相同，用于区分这两个不同的路由器接口。

<img src="computer_network_hnust.assets/image-20220128165538147.png" alt="image-20220128165538147" style="zoom:50%;" />

- 192,172,10分别的C,B,A地址，他们的网络号不一样，看到后面的IP分类就知道了



---



3，第三个问题，路由选择问题：

我们来举例说明，如图所示，数据包从源站到目的站可以走这样的一条路

<img src="computer_network_hnust.assets/image-20220128165728330.png" alt="image-20220128165728330" style="zoom:50%;" />

也可以走这样一条路径

<img src="computer_network_hnust.assets/image-20220128165814049.png" alt="image-20220128165814049" style="zoom:50%;" />

对于本例还有其他路径可走，我们就不一一演示了。那么路由器收到数据包后是依据什么来决定将数据包从自己的哪个接口转发出去的呢？这个问题在我们之间的课程中曾简单介绍过，即依据的是”数据包中的目的地址“和”路由器中的路由表“。例如本图是路由器R1的路由表，里面记录着路由器R1所知道的网络，以及数据包要到达这些网络应该从自己的哪个接口转发：

![image-20220128170349077](computer_network_hnust.assets/image-20220128170349077.png)

假设R1知道数据包要到达N7的话，下一跳应将其转发给路由器R4，则路由表中应该有这样一条记录：

![image-20220128170526192](computer_network_hnust.assets/image-20220128170526192.png)

而数据包要达到网络N6，下一跳应将其转发给路由器R2，则路由表中应该有这样一条记录：

![image-20220128170858257](computer_network_hnust.assets/image-20220128170858257.png)

想想看，刚在是我们假设路由器知道路由表中的这些记录，但是在实践当中，路由器是如何得到这样的路由记录的呢？有两种方法：

- 由用户或网络管理人员进行**人工配置**。这种方法只适用于规模较小，且网络拓扑不改变的小型互联网。
- **实现各种路由选择协议**，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路由记录。这种方法更适用于规模较大，且网络拓扑经常改变的大型互联网。



#### TCP/IP协议栈的网际层

1，**因特网**(Internet)是目前全世界用户数量最多的互联网，它使用**TCP/IP协议栈**。

2，由于TCP/IP协议栈的网络层使用**网际协议IP**，它是整个协议栈的核心协议，因此在TCP/IP协议栈中网络层常称为**网际层**。
3，综上所述，我们通过学习TCP/IP协议栈的网际层来学习网络层的理论知识和实践技术。

4，TCP/IP协议栈各层，及各层包含的主要协议图示：

![image-20220128171653885](computer_network_hnust.assets/image-20220128171653885.png)



### 网络层提供的两种服务

#### 面向连接的虚电路服务

1，虚电路的核心思想：**可靠通信由网络来保证**

2，两台计算机进行通信时，应当首先建立**网络层的连接**，也就是建立一条**虚电路VC**(Virtual Circuit)，以保证通信双方所需的一切网络资源：

![image-20220128192850260](computer_network_hnust.assets/image-20220128192850260.png)

3，然后**双方就沿着已建立的虚电路发送分组**。

![image-20220128193017058](computer_network_hnust.assets/image-20220128193017058.png)

- 需要说明的是，虚电路表示这是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而不是真正建立了一条物理连接。而采用电路交换的电话通信则是先建立一条真正的连接。因此分组交换的虚连接与电路交换的连接只是类似，但并不完全一样。

4，目的主机的地址仅在连接建立阶段使用，之后每个**分组的首部只需携带一条虚电路的编号**(构成虚电路的每一段链路都有一个虚电路编号)。

5，这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复)。

6，**通信结束后，需要释放之前所建立的虚电路**。

7，很多广域分组交换网都使用面向连接的虚电路服务。例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。

8，然而因特网的先驱者并没有采取这种设计思路，而是采用了无连接的数据报服务



#### 无连接的数据报服务

1，数据报服务的核心思想是：**可靠通信应当由用户主机来保证**

2，当两台计算机进行通信时，**他们的网络层不需要先建立连接**，**每个分组可走不同的路径**

![image-20220128193825631](computer_network_hnust.assets/image-20220128193825631.png)

3，因此，**分组的首部必须携带目的主机的完整地址**

4，这种通信方式所传送的**分组可能误码**、**丢失**、**重复**和**失序**。这些传输差错我们在之前的课程中就已经介绍过了，就不再赘述了。

5，由于**网络本身不提供端到端的可靠传输服务**，这就使网络中的路由器可以做得比较简单，而且价格低廉（比电信网的交换机的价格低廉)。

6，因特网采用了这种设计思想，也就是**将复杂的网络处理功能置于因特网的边缘(用户主机和其内部的运输层)**，而将相对简单的尽最大努力的分组交付功能置于因特网核心。

- 采用这种思想的好处是网络的造假大大降低，运行方式灵活，能够适应多种应用。
- 因特网能发展到今天的这种规模，充分证明了当初采用这种设计思想的正确性。



#### 小结

![image-20220128194359461](computer_network_hnust.assets/image-20220128194359461.png)



### IPv4地址概述

#### 基本概念

![image-20220128195341584](computer_network_hnust.assets/image-20220128195341584.png)

#### IPV4地址表示方法

![image-20220128195503846](computer_network_hnust.assets/image-20220128195503846.png)

- 注意：**ipv4地址**常写成**点分十进制**表示方法，方便使用。



#### 8位无符号二进制整数转十进制数

1，点分十进制中两个点之间的数，就是用8位无符号二进制换算过来的。所以数的范围为0~255(2的8次方为256)。

2，具体换算方法：

![image-20220128200220099](computer_network_hnust.assets/image-20220128200220099.png)



#### 十进制正整数转8位无符号二进制数

![image-20220128200411002](computer_network_hnust.assets/image-20220128200411002.png)

- 网友说：“凑数不实用”



### 分类编址的IPv4地址

分类编址是IPv4地址编址方法的第一个历史阶段。

#### 五类地址概述

![image-20220129144226215](computer_network_hnust.assets/image-20220129144226215.png)



#### A类地址细节

![image-20220129145414254](computer_network_hnust.assets/image-20220129145414254.png)

- 网友问：“为什么最小本地环回测试地址不为127.0.0.0？”。网友答：“因为主机号不能全是0，不然就是代表一个网络地址表示一个子网”。
- 网友问：“什么是环回测试地址？”。网友答：“”
- 注意：
  - 主机号全部取0，则该地址为该网络的网络地址
  - 主机号全部取1，则该地址为该网络的广播地址



#### B类地址细节

![image-20220129150206185](computer_network_hnust.assets/image-20220129150206185.png)

- B类地址的网络号有16位，且最高两位固定为“10”，因此B类地址网络号有2的(16-2)次方个组合



#### C类地址细节

![image-20220129150746938](computer_network_hnust.assets/image-20220129150746938.png)



#### ABC类地址小练习

1，

![image-20220129150943015](computer_network_hnust.assets/image-20220129150943015.png)



2，有关源地址和目的地址的练习题：

![image-20220129151149736](computer_network_hnust.assets/image-20220129151149736.png)

3，网络分配练习：

![image-20220129152504824](computer_network_hnust.assets/image-20220129152504824.png)

- 网络ip规划时不要忘记，红色背景的，两台路由器通过一段链路直连，他们的直连接口也属于同一个网络。

- 黄色网络的主机数量为65534，加上一个路由器接口，需要可分配的IP地址数量为65535，只能给该网络分配一个A类网络号。
- 蓝色网络的主机数量为254，加上一个路由器接口，需要可分配的IP地址数量为255，可以给该网络分配一个A类或B类网络号；本着节约IP地址的原则，给该网络分配一个B类网络号。
- 蓝色网络的主机数量为40，加上一个路由器接口，需要可分配的IP地址数量为41，可以给该网络分配一个A类或B类或C类网络号；本着节约IP地址的原则，给该网络分配一个C类网络号。

- 红色网络没有主机，只有两个路由器接口，需要可分配的IP地址数量为2，给该网络分配一个A类或B类或C类网络号都可以；本着节约IP地址的原则，给该网络分配一个C类网络号。
- 网络号分配完毕后，就可以给各网络中的各主机和路由器的各接口分配IP地址了。需要注意的是，所分配的IP地址应该互不相同，并且其主机号部分不能出现全0(因为这是网络地址)，也不能出现全1(因为这是广播地址)；网络地址或者主机地址都不能分配给各主机或路由器的各接口，因为他们无法唯一标识一台主机或路由器的某个接口。



### 划分子网的IPv4地址

划分子网是IPv4地址编址方法的第二个历史阶段。



#### 为何出现划分子网的需求

1，如图所示，某单位有一个大型局域网需要连接到因特网；如果申请一个C类网络地址，其可分配的IP地址数量只有254个，不够使用；因此该单位申请了一个B类网络地址，其可分配的IP地址数量达到了65534个：

![image-20220129160811553](computer_network_hnust.assets/image-20220129160811553.png)

2，给每台计算机和路由器的接口分配一个IP地址后，还有大量的IP地址剩余；这些剩余的IP地址只能由该单位的同一个网络使用，而其他单位的网络不能使用：

![image-20220129160957240](computer_network_hnust.assets/image-20220129160957240.png)

3，随着该单位计算机网络的发展与建设，该单位又新增了一些计算机，并且需要将原来的网络划分成3个独立的网络，我们称其为“子网1，子网2，子网3”：

![image-20220129161221259](computer_network_hnust.assets/image-20220129161221259.png)

4，假设子网1仍然使用原先申请到的B类网络地址，那么久需要为子网2和子网3各自申请一个网络地址，但这样会存在一些弊端：

![image-20220129162210223](computer_network_hnust.assets/image-20220129162210223.png)

- 如果可以从IP地址的主机号部分借用一些位作为子网号来区分不同的子网，就可以利用原有网络中剩余的大量IP地址，而不用申请新的网络地址。

5，对于本例，我们可以借用16位主机号中的8位作为子网号：

![image-20220129162618021](computer_network_hnust.assets/image-20220129162618021.png)

- 假设我们给子网1分配的子网号是0，给子网2分配的子网号是1，给子网3分配的子网号是2。



6，之后就可以给各子网中的主机和路由器接口分配IP地址了：

![image-20220129162715997](computer_network_hnust.assets/image-20220129162715997.png)



7，思考一个问题：

![image-20220129162808377](computer_network_hnust.assets/image-20220129162808377.png)

- 这样我们就引出了一个划分子网的工具：子网掩码



#### 子网掩码介绍

1，**32比特的子网掩码可以表明分类IP地址的主机号部分被借用了几个比特作为子网号**

2，这是32bit的分类IPv4地址，它由网络号和主机号两部分构成：

![image-20220129163640823](computer_network_hnust.assets/image-20220129163640823.png)

3，当我们从主机号部分借用一些位作为子网号时，IP地址从两级结构的分类IP地址，变成了三级结构的划分子网的IP地址：

![image-20220129163841198](computer_network_hnust.assets/image-20220129163841198.png)

4，子网掩码用**连续的比特1来对应网络号和子网号**，子网掩码用**连续的比特0来对应主机号**；这样就构成了这个划分子网的IP地址的32比特的子网掩码：

![image-20220129164026292](computer_network_hnust.assets/image-20220129164026292.png)

5，将划分子网的**IPv4地**址与其相应的**子网掩码**进行**逻辑与运算**就可得到IPv4地址**所在子网的网络地址**

![image-20220129164303932](computer_network_hnust.assets/image-20220129164303932.png)

- 与 0 是清零主机号的功能 与1是保留网络号和子网号的功能



#### 划分子网的细节

1，已知某个网络的地址为218.75.230.0，使用子网掩码255.255.255.128对其进行子网划分，请给出划分细节。

2，218.75.230.0是给定的网络地址，从他的左起第一个十进制数可知，这是一个C类网络地址；因此网络号占三个字节，主机号占一个字节：

![image-20220129165304456](computer_network_hnust.assets/image-20220129165304456.png)

3，255.255.255.128是题目给定的子网掩码；前三个十进制数255的二进制为24个连续的比特1，他们对应IP地址中的网络号部分：

![image-20220129170034826](computer_network_hnust.assets/image-20220129170034826.png)

4，而该子网掩码中的十进制数128，用来表示从IP地址的主机号部分借用了多少比特来作为子网号，我们将其转换为8个二进制比特；其中只有1个比特1，这就表明从主机号部分借用1个比特作为子网号：

![image-20220129170152353](computer_network_hnust.assets/image-20220129170152353.png)

5，因此可划分出的子网数量，和每个子网可分配的地址数量如图：

![image-20220129170713364](computer_network_hnust.assets/image-20220129170713364.png)

- 由于原来8位主机号被借走1位作为子网号，因此主机号还剩7位，这就是表达式中8-1的原因，可有2的7次方个组合；但是我们还要去掉主机号为“全0”的网络地址和“全1”的广播地址，这就是表达式中-2的原因。

6，我们再来看题目所给的C类网地址218.75.230.0的细节：

![image-20220129171739880](computer_network_hnust.assets/image-20220129171739880.png)

- 因为这是一个C类网地址，因此网络号占3个字节，主机号占1个字节。
- 该网络共有256个地址；218.75.230.0是该网络上的第一个地址，也就是主机号全为0的地址，作为该网络的网络地址；将网络号保持不变，主机号取最大值255，这就是该网络上的最后一个地址，作为该网络的广播地址，也就是主机号全为1的地址。
- 该网络可分配的地址数量为254个。

7，之前我们已经分析过了，题目所给的子网掩码表明从主机号部分借用1个比特作为子网号，也就是将该C类网均分为两个子网；我们将主机号写成8比特的形式，从主机号借用一个比特作为子网号，子网号只能是0或1。因此给定C类网地址218.75.230.0的子网划分如下：

![image-20220129172214269](computer_network_hnust.assets/image-20220129172214269.png)

#### 划分子网小练习

1,

![image-20220129172344949](computer_network_hnust.assets/image-20220129172344949.png)

2,

![image-20220129172440856](computer_network_hnust.assets/image-20220129172440856.png)

由网络号的第一位180可知，180.80.77.55是B类网络地址，因此网络号占两个字节，主机号也占两个字节：

![image-20220129172821649](computer_network_hnust.assets/image-20220129172821649.png)

将网络号和子网号保持不变，而将主机号的10个比特全部取0，就可以得到该主机所在子网的网络地址；将网络号和子网号保持不变，而将主机号的10个比特全部取1，就可以得到该主机所在子网的广播地址：

![image-20220129173047765](computer_network_hnust.assets/image-20220129173047765.png)

因此本题的答案为选项D。



#### 默认子网掩码

![image-20220129173220128](computer_network_hnust.assets/image-20220129173220128.png)

#### 小结与重点

![image-20220129173341987](computer_network_hnust.assets/image-20220129173341987.png)



### 无分类编址的IPv4地址

无分类编制是IPv4地址编址方法的第三个历史阶段。



#### 无分类编址简介

![image-20220129180525972](computer_network_hnust.assets/image-20220129180525972.png)

![image-20220129180707874](computer_network_hnust.assets/image-20220129180707874.png)



#### 无分类编址实例说明

1，题目：

![image-20220129181118283](computer_network_hnust.assets/image-20220129181118283.png)

2，128.14.35.7/20是题目所给的地址块；斜线后面的数字为20，表明该IPv4地址的前20个比特为网络前缀；也就是说，所给地址的“左起第一个字节，第二个字节，以及第三个字节的前4比特”构成20比特的网络前缀，剩余12个比特为主机号；因此我们要将该地址的第三个字节和第四个字节转换成二进制的形式，这样我们就很容易看出20比特的网络前缀和12比特的主机号：

![image-20220129181656815](computer_network_hnust.assets/image-20220129181656815.png)

3，将20比特的网络前缀保持不变，12比特的主机号全部取0，就可以得到该地址块的最小地址：

![image-20220129181803258](computer_network_hnust.assets/image-20220129181803258.png)

4，将20比特的网络前缀保持不变，12比特的主机号全部取1，就可以得到该地址块的最大地址：

![image-20220129181843352](computer_network_hnust.assets/image-20220129181843352.png)

5，该地址块中的地址数量如图：

![image-20220129182033221](computer_network_hnust.assets/image-20220129182033221.png)

- 因为32比特的IPv4地址中前20个比特为网络前缀，剩余12比特为主机号，因此主机号可有2的12次方个组合

- 这个也是区分网络地址和广播地址的，因为只是写出地址数量，网络和广播都算地址

6，聚合C类网的数量，用该地址块中的地址数量，除以一个C类网的地址数量2的8次方个，即可得出：

![image-20220129182216405](computer_network_hnust.assets/image-20220129182216405.png)

7，地址掩码为20个连续的比特1，和12个连续的比特0：

![image-20220129182416311](computer_network_hnust.assets/image-20220129182416311.png)

- 20个连续的比特1用来对应网络前缀
- 12个连续的比特0用来对应主机号



#### 无分类编址小练习

![image-20220129182455212](computer_network_hnust.assets/image-20220129182455212.png)



#### CIDR中的路由聚合

1，路由器R1与五个网络以及路由器R2直接相连，路由器R1和R2互为相邻路由器，他们周期性的通告自己所知道的路由信息给对方：

![image-20220129182816520](computer_network_hnust.assets/image-20220129182816520.png)

- 思考：R1应该将怎样的路由信息通告给R2？

2，如果R1把自己直连的这五个网络的路由记录都通报给R2，则R2的路由表会增加5条路由记录，如图所示：

![image-20220129183704351](computer_network_hnust.assets/image-20220129183704351.png)

3，为了减少路由记录对路由表的占用，能否将这五条路由记录聚合成一条呢？答案是肯定的：

![image-20220129183820491](computer_network_hnust.assets/image-20220129183820491.png)

4，其方法是“找共同前缀”，也就是找出这5个目的网络地址的共同前缀；这五个目的网络地址左起前两个字节都是相同的，从第三个字节开始不同，因此只需将第三个字节转换成二进制形式，这样就很容易找出这五个目的网络地址的共同前缀，共22比特，将其记为“/22”：

![image-20220129184116151](computer_network_hnust.assets/image-20220129184116151.png)

5，将共同前缀保持不变，而剩余的比特全部取0，然后写成点分十进制形式，放在“/22”的前面；这就是聚合后的地址块，也可以成为超网：

![image-20220129184302760](computer_network_hnust.assets/image-20220129184302760.png)

6，通过本例，我们还可以看出**网络前缀越长，地址块越小，路由越具体**。

- 需要说明的是：若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为**最长前缀匹配**，因为这样的路由更具体。



#### 聚合路由小练习

1，

![image-20220129185022655](computer_network_hnust.assets/image-20220129185022655.png)

- 题目中给定的IP分组的目的地址为192.168.4.3，这是该网络的广播地址，因此该网络上的所有主机都能收到。由于该网络只有两个可分配的IP地址，因此网络中的主机数量最大为2，那么可以收到该IP分组的最大主机数就是2.

2，

![image-20220129185138682](computer_network_hnust.assets/image-20220129185138682.png)



#### 小结与重点

![image-20220129185231512](computer_network_hnust.assets/image-20220129185231512.png)





### IPv4地址的应用规划

#### 规划方法简介即小结

![image-20220129213107681](computer_network_hnust.assets/image-20220129213107681.png)



#### 定长的子网掩码划分子网实例

1，要求：

![image-20220129201531904](computer_network_hnust.assets/image-20220129201531904.png)

2，得到每个网络所需的IP地址数量：

![image-20220129201921358](computer_network_hnust.assets/image-20220129201921358.png)

- 我们可以将图中两个路由器之间的这段链路看成是网络N5，其中没有主机，因此主机需要的地址数量为0.

3，得到应用需求:将C类网络218.75.230.0划分成5个子网，每个子网上可分配的IP地址数量不得少于各自的需求。

4，C类网络地址218.75.230.0分析如下：

![image-20220129202342045](computer_network_hnust.assets/image-20220129202342045.png)

- 子网数量8个，可以满足我们对子网数量的要求；每个子网上的地址数量为32个，可以满足我们对子网上IP地址数量的要求

5，这样我们就可以得出划分子网所需的子网掩码；用三个十进制数255来对应网络号部分；而最后的8个比特为11100000

![image-20220129202607325](computer_network_hnust.assets/image-20220129202607325.png)

6，将子网掩码的最后8比特写成十进制数为224：

![image-20220129202659053](computer_network_hnust.assets/image-20220129202659053.png)

7，接下来我们来看划分子网的细节，以前两个子网为例：

![image-20220129202929984](computer_network_hnust.assets/image-20220129202929984.png)

- 子网号部分是从主机号借用的3比特。

8，以此类推，我们可以得到划分子网的全部细节：

![image-20220129203049680](computer_network_hnust.assets/image-20220129203049680.png)

9，现在我们可以从子网1~8中任选5个分配给图中的网络N1~N5：

![image-20220129203201792](computer_network_hnust.assets/image-20220129203201792.png)

- 通过本例可以看出，通过定长的子网掩码进行子网划分，只能划分出2的n次方个子网；其中n是从主机号部分借用的用来作为子网号的比特数量。

- 每个子网所分配的ip地址数量相同，容易造成IP地址的浪费。例如图中的网络5只需要4个ip地址，但是我们只能给他分配32个ip地址，这样造成ip地址的严重浪费。



#### 变长的子网掩码划分子网实例

1，本例与之前的例子基本一样，只是划分子网的方法改为采用变长的子网掩码，要求如下：

![image-20220129204140007](computer_network_hnust.assets/image-20220129204140007.png)

2，这是我们之前就统计过的各网络所需IP地址的数量：

![image-20220129204231818](computer_network_hnust.assets/image-20220129204231818.png)

3，既然网络N1需要9个地址，那么分配给网络N1的地址的主机号应为4比特，因为2的四次方等于16，这样网络N1就可有16个地址。由于使用4比特作为主机号，因此剩余28个比特可作为网络前缀：

![image-20220129210053114](computer_network_hnust.assets/image-20220129210053114.png)

4，既然网络N2需要28个地址，那么分配给网络N2的地址的主机号应为5个比特，因为2的5次方等于32，这样网络N2就可有32个地址；由于使用5个比特作为主机号，因此剩余27个比特可作为网络前缀：

![image-20220129210431770](computer_network_hnust.assets/image-20220129210431770.png)

5，同理得出分配给网络N3，N4，N5的地址中的主机号所占比特数量和网络前缀所占比特数量，就不在赘述了；我们将所得出的各网络所需地址块的大小标注在他们各自的旁边：

![image-20220129210825793](computer_network_hnust.assets/image-20220129210825793.png)

6，这样我们就可以得到本例的应用需求:从地址块218.75.230.0/24中取出5个地址块(1个“/27”地址块，3个“/28”地址块，1个“/30"地址块)，按需分配给下图所示的5个网络：

![image-20220129211130428](computer_network_hnust.assets/image-20220129211130428.png)

7，218.75.230.0/24地址块所包含的全部地址如下所示:

![image-20220129211225328](computer_network_hnust.assets/image-20220129211225328.png)

- 注意这里的**分配原则**。

8，例如，将这32个地址作为一个地址块分配给网络N2，我们将网络N2所分配到的地址块标注在它的旁边：

![image-20220129211627820](computer_network_hnust.assets/image-20220129211627820.png)

- 地址块中最小的地址就是N2的网络地址，最大的地址就是N2的广播地址；网络地址和广播地址之间的这些地址可分配给N2中的主机或路由器接口。

9，同理，N1N3N4N5的分配如下图所示：

![image-20220129212221245](computer_network_hnust.assets/image-20220129212221245.png)

- 原地址块中还剩余的这些地址可以留作今后分配。

10，通过本例可以看出，采用变长的子网掩码进行子网划分，可以按需划分出相应数量的子网，每个子网所分配到的IP地址数量可以不相同，尽可能减少了对IP地址的浪费。例如，图中给的网络5只需要4个ip地址，我们也非常精确地给它分配了4个IP地址，没有造成IP、地址的浪费。



#### 变长的子网掩码划分子网习题

![image-20220129212938427](computer_network_hnust.assets/image-20220129212938427.png)

- 本题答案并不唯一，和实例类似，就不再赘述了。



### IP数据报的发送和转发过程

#### 构成

![image-20220130082958948](computer_network_hnust.assets/image-20220130082958948.png)



#### 实例

1，在下图所示的小型互联网中，路由器的接口0直连了一个交换式以太网，路由器的接口1也直连了一个交换式以太网：

![image-20220130085755286](computer_network_hnust.assets/image-20220130085755286.png)

2，我们给绿色背景的网络分配了网络地址和子网掩码，给网络中的各主机和路由器的接口配置了相应的IP地址和子网掩码，如图所示：

![image-20220130090030136](computer_network_hnust.assets/image-20220130090030136.png)

3，我们给黄色背景的网络也分配了网络地址和子网掩码，给网络中的各主机和路由器的接口配置了相应的IP地址和子网掩码，如图所示：

![image-20220130090124648](computer_network_hnust.assets/image-20220130090124648.png)

4，我们知道，同一个网络的主机之间可以直接通信，这属于直接交付；不同网络的主机之间的通信需要通过路由器来中转，这属于间接交付：

![image-20220130090536966](computer_network_hnust.assets/image-20220130090536966.png)

- 那么源主机如何知道目的主机是否与自己在同一个网络中呢？

5，我们来举例说明

6，假设主机C要给主机F发送IP数据报，主机C将自己的IP地址和子网掩码相与，就可以得到主机C所在网络的网络地址：

![image-20220130091126011](computer_network_hnust.assets/image-20220130091126011.png)

7，既然主机C要给主机F发送IP数据报，那主机C肯定知道主机F的IP地址，否则就没法发送了；主机C将主机F的IP地址与自己的子网掩码相与，就可以得到目的网络地址；该地址与主机C的网络地址不相等，因此主机C就知道了主机F与自己不在同一个网络，他们之间的通信属于间接交付：

![image-20220130091601118](computer_network_hnust.assets/image-20220130091601118.png)

8，因为是间接交付，主机C需要将IP数据报传输给路由器，由路由器将IP数据报转发给主机F：

![image-20220130092029974](computer_network_hnust.assets/image-20220130092029974.png)

- 那么主机C又是如何应该把IP数据报交给哪个路由器进行转发呢？

9，实际上，用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络中的一个路由器，由该路由器帮忙进行转发；所指定的路由器，也被称为默认网关；对于本例，我们可以将路由器接口0的IP地址指定给该接口所直连网络中的各个主机作为默认网关：

![image-20220130093026923](computer_network_hnust.assets/image-20220130093026923.png)

10，同理，可将路由器接口1的ip地址，指定给该接口所直连网络中的各个主机作为默认网关：

![image-20220130093307685](computer_network_hnust.assets/image-20220130093307685.png)

11，这样，当本网络中的主机要和其他网络中的主机进行通信时，会将IP数据报传输给默认网关，由默认网关帮主机将IP数据报转发出去

12，假设本例中的主机A要给主机D发送IP数据报，这属于间接交付；主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器：

![image-20220130093937882](computer_network_hnust.assets/image-20220130093937882.png)

- 那么当路由器收到IP数据报后又是如何转发的呢？答案在本图中的①②。

13，为了简单起见，我们假设本例中的IP数据包首部没有出现差错，路由器取出IP数据报首部各地址字段的值；源地址字段为主机A的IP地址，目的地址字段的值为主机D的ip地址：

![image-20220130094242972](computer_network_hnust.assets/image-20220130094242972.png)

14，接下来，路由器就要对该IP数据报进行查表转发了。

15，这是路由器的路由表，当我们给路由器的接口配置IP地址和子网掩码时，路由器就知道了自己的该接口与哪个网络是直连的；例如在本例中，接口0所直连的网络是192.168.0.0，相应的地址掩码为255.255.255.128，因为接口0和该网络是直连的所以不需要下一跳路由器；接口1所直连的网络是192.168.0.128，相应的地址掩码为255.255.255.128，因为接口1和该网络是直连的所以不需要下一跳路由器：

![image-20220130095310766](computer_network_hnust.assets/image-20220130095310766.png)

- 需要说明的是，路由表中可能还会有其他路由条目，这可以是用户或网络管理员手工配置的静态路由，也可以是路由器使用路由协议自动获取到的动态路由。将在后续课程中详细介绍这部分内容。

16，接下来，路由器根据IP数据报的目的地址在自己的路由表中查找匹配的路由条目，逐条检查路由条目，将目的地址与路由条目中的地址掩码相与得到目的网络地址；该目的网络地址与路由条目中的目的网络地址不相同，则这条路由条目不匹配：

![image-20220130095726710](computer_network_hnust.assets/image-20220130095726710.png)

17，再检查下一条路由条目，将目的地址与下一条路由条目中的地址掩码相与得到目的网络地址；该目的网络地址与路由条目中的目的网络地址相同，则这条路由条目就是匹配的路由条目：

![image-20220130095942965](computer_network_hnust.assets/image-20220130095942965.png)

18，按照它的下一跳指示，也就是从接口1转发该IP数据报，这样主机D就可以收到路由器转发来的该IP数据报：

![image-20220130100406869](computer_network_hnust.assets/image-20220130100406869.png)

- 需要说明的是，我们这里所介绍的路由器查表转发IP数据报的过程，只是为了让同学们理解其最基本的工作原理；在路由器的实际研发过程中，需要设计很好的数据结构以便提高查找速度。

19，再来看这种情况，假设主机A给本网络上的各设备发送了一个广播IP数据报，在数据报首部中的目的地址字段，可以填写的目的地址为192.168.0.127，这是本网络的广播地址；也可以填写255.255.255.255，这是受限的广播地址：

![image-20220130101100291](computer_network_hnust.assets/image-20220130101100291.png)

20，该网络中的各设备都会收到该广播IP数据报；但路由器收到后并不会转发该数据报，也就是说**路由器是隔离广播域的**：

![image-20220130101211415](computer_network_hnust.assets/image-20220130101211415.png)

- 路由器隔离广播域是很有必要的。试想一下，如果因特网中数量巨大的路由器收到广播IP数据报后都进行转发，则会造成巨大的广播风暴，严重浪费因特网资源。

21，同理，主机A给另一个网络发送广播IP数据报：

![image-20220130102005847](computer_network_hnust.assets/image-20220130102005847.png)

22，在数据报首部中的目的地址字段填写的目的地址为192.168.0.255，这是网络192.168.0.128的广播地址；主机A将该广播IP数据报传输给路由器，希望由路由器帮其转发：

![image-20220130102115541](computer_network_hnust.assets/image-20220130102115541.png)

23，但路由器判断处这是广播IP数据报，不会转发：

![image-20220130102203072](computer_network_hnust.assets/image-20220130102203072.png)



#### 小练习

1，

![image-20220130102319031](computer_network_hnust.assets/image-20220130102319031.png)

2，

![image-20220130102349699](computer_network_hnust.assets/image-20220130102349699.png)

- III可以检错，但不能确保不丢失

3，

![image-20220130103016343](computer_network_hnust.assets/image-20220130103016343.png)

- 从主机1的子网掩码和主机1的IP地址的的CIDR表示方法都回以看出，网络前缀为24个比特；而WWW服务器的IP地址的网络前缀也是24个比特，并且与主机1的网络前缀相同，因此主机1可以访问WWW服务器。



#### 小结

![image-20220130103115134](computer_network_hnust.assets/image-20220130103115134.png)



### 静态路由配置及其可能产生的路由环路问题

#### 概述

![image-20220130112356002](computer_network_hnust.assets/image-20220130112356002.png)



#### 举例说明静态路由配置

1，我们采用如图所示的网络拓扑和相应的IP地址配置。

![image-20220130122340388](computer_network_hnust.assets/image-20220130122340388.png)

2，这是路由器R1的路由表，路由器R1通过自己的接口0所配置的IP地址和地址掩码，可以自动得出接口0所在的网络；由于接口0与该网络直连，则下一条不是路由器地址，而是通过接口0转发IP数据报给该网络中的某个主机，这属于直接交付，这条自动得出的路由条目的类型属于直连路由：

![image-20220130122634074](computer_network_hnust.assets/image-20220130122634074.png)

3，同理，R1还可以自行得出接口1的直连网络路由条目：

![image-20220130122808140](computer_network_hnust.assets/image-20220130122808140.png)

4，这是路由器R2的路由表；可以看到其接口0的直连网络路由条目，和其接口1的直连网络路由条目：

![image-20220130122952812](computer_network_hnust.assets/image-20220130122952812.png)

5，假设R1要转发一个IP数据报给该网络中的某个主机，从图中可以看出，R1应该将该IP数据报转发给路由器R2的接口0：

![image-20220130123408823](computer_network_hnust.assets/image-20220130123408823.png)

6，但R1的路由表中并没有关于该目的网络的路由条目，换句话说，R1并不知道目的网络192.168.2.0/24的存在；因此我们可以使用路由器的相关配置命令，给R1添加一条到达该目的网络的路由条目：

![image-20220130131625975](computer_network_hnust.assets/image-20220130131625975.png)

- 192.168.2.0/24是目的网络的地址；下一跳为路由器R2的接口0的地址；该路由条目是我们人工配置的静态路由。

7，假设R2要转发一个IP数据报给该网络中的某个主机，从图中可以看出，R2应该将该IP数据报转发给路由器R1的接口1，但R2的路由表中并没有关于该目的网络的路由条目；因此我们可以给R2添加一条到达该目的网络的路由条目：

![image-20220130131457077](computer_network_hnust.assets/image-20220130131457077.png)

8，以上就是我们举例说明的静态路由配置



#### 默认路由的概念实例

1，假设路由器R2的接口2连接到了因特网；如下是路由器R1的路由表，可以看到其接口0的直连网络路由条目，和其接口1的直连网络路由条目，和人工配置的到达该目的网络的静态路由：

![image-20220130132427366](computer_network_hnust.assets/image-20220130132427366.png)

2，假设R1要转发一个IP数据报给因特网中某个网络的某个主机，从图中可以看出，R1应该将该IP数据报转发给路由器R2的接口0；由于因特网中包含了众多的网络，如果我们给R1添加针对这些网络的每一条路由条目,则会给人工配置带来巨大的工作量，并且使R1的路由表变得非常大，降低查表转发的速度：

![image-20220130133743939](computer_network_hnust.assets/image-20220130133743939.png)

3，实际上，对于具有相同下一跳的不同目的网络的路由条目，我们可以用一条默认路由条目来替代；默认路由条目中的目的网络地址为0.0.0.0，地址掩码也为0.0.0.0，其CIDR形式为0.0.0.0/0；对于本例，默认路由条目的下一跳是路由器R2的接口0的地址；由于默认路由也是由我们人工配置的，因此其类型也是静态：

![image-20220130134234751](computer_network_hnust.assets/image-20220130134234751.png)

- 默认路由：是一种特殊的静态路由，当路由表中与数据包目的地址没有匹配的表项时，数据包将根据默认路由条目进行转发。

4，在配置了默认路由条目后，我们甚至可以删除这条路由条目：

![image-20220130134410511](computer_network_hnust.assets/image-20220130134410511.png)



#### 特定主机路由实例

1，我们举例说明特定主机路由的概念，我们可以给路由器添加针对某个主机的特定主机路由条目。

- 特定主机路由条目用处：
  - 一般用于网络管理人员对网络的管理和测试。
  - 另外，在需要考虑某种安全问题时也可以采用特定主机路由。

2，假设这是该网络中的某台特定主机，我们可以在R1的路由表中，添加一条到达该主机的特定主机路由条目；特定主机路由条目中的目的网络地址为该特定主机的ip地址，地址掩码为255.255.255.255，其CIDR形式为特定主机IP地址/32；对于本例，特定主机路由条目的下一跳是路由器R2的接口0的地址；由于特定主机路由也是由我们人工配置的，因此其类型也是静态：

![image-20220130135737028](computer_network_hnust.assets/image-20220130135737028.png)

- 注意：特定网络路由的网络前缀最长，路由最具体，会被最优先匹配。
- 我理解：“特定网络路由相当于把特定主机的ip地址看作了一个无敌小的网络。”



#### 静态路由配置错误导致的路由环路实例

1，如图所示，这是各路由器自动得出的直连网络，和人工配置的静态路由

![image-20220130140609963](computer_network_hnust.assets/image-20220130140609963.png)

2，我们来看看路由器R2中的这条人工配置的静态路由条目，它表明R2要转发IP数据报到该网络，下一跳应转发给R1的接口1：

![image-20220130140848993](computer_network_hnust.assets/image-20220130140848993.png)

3，假设我们将下一跳错误地配置成了该地址，也就是错误地指向了R3的接口0：

![image-20220130141219347](computer_network_hnust.assets/image-20220130141219347.png)

4，当R2要转发IP数据报到该网络时，下一跳会错误地转发给路由器R3的接口0：

![image-20220130141410163](computer_network_hnust.assets/image-20220130141410163.png)

5，R3收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳应该转发给R2的接口1：

![image-20220130154900434](computer_network_hnust.assets/image-20220130154900434.png)

6，R2收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳应该转发给R3的接口0,：

![image-20220130155050687](computer_network_hnust.assets/image-20220130155050687.png)

7，很显然，由于我们静态路由配置错误，导致R2和R3之间产生了路由环路。

- 为了防止IP数据报在路由环路中永久兜圈，在IP数据报首部设有生存时间TTL字段。IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。



#### 聚合了不存在的网络可能导致的环路问题实例

1，路由器R1的路由表如图；可以看到其自动得出的直连网络；还可以看到人工配置的默认路由，下一跳指向路由器R2的接口0：

![image-20220130155555864](computer_network_hnust.assets/image-20220130155555864.png)

2，路由器R2的路由表如图；可以看到其自动得出的直连网络；还可以看到人工配置的**聚合路由**，是由箭头所指的两个网络聚合而来的：

![image-20220130160453021](computer_network_hnust.assets/image-20220130160453021.png)

- 聚合的方法就是找两个地址的共同前缀，然后将共同前缀保持不变，将剩余比特全部取0；写成点分十进制形式，在其后面写上“/”，“/”后面写上共同前缀的数量。

3，假设R2要转发IP数据报到该网络；进行查表转发，找到了匹配的路由条目，下一跳应该转发给该地址，也就是转发给R1的接口1：

![image-20220130160813588](computer_network_hnust.assets/image-20220130160813588.png)

4，R1收到该IP数据报后，进行查表转发，找到了匹配的路由条目，下一跳是通过接口2直接交付：

![image-20220130160946376](computer_network_hnust.assets/image-20220130160946376.png)

5，我们再来看看这条聚合路由的细节，他实际上包含了以下四个网络，有两个网络实际上不存在于网络拓扑中，

![image-20220130161312684](computer_network_hnust.assets/image-20220130161312684.png)

6，当R2要转发IP数据报到这个不存在的网络时；进行查表转发，找到了匹配的路由条目，下一跳应该转发给R1的接口1；但是对于这个不存在的网络，路由器R2应该不予转发，却错把它转发给了路由器R1：

![image-20220130161527906](computer_network_hnust.assets/image-20220130161527906.png)

7，R1收到该IP数据报后，进行查表转发，只能走默认路由，下一跳应该转发给R2的接口0；很显然，R1和R2之间产生了路由环路：

![image-20220130161934687](computer_network_hnust.assets/image-20220130161934687.png)

8，针对这种情况，我们可以在R2的路由表中添加“所聚合的，不存在的”网络的黑洞路由；黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，可以形象的看成是一个黑洞，IP数据报进入它后就有去无回了，也就是路由器丢弃了该IP数据报，而不是转发该IP数据报：

![image-20220130162203215](computer_network_hnust.assets/image-20220130162203215.png)



9，现在假设R2要转发IP数据报到这个不存在的网络，进行查表转发，找到了两条可选的路由条目：

![image-20220130162411461](computer_network_hnust.assets/image-20220130162411461.png)

10，根据最长前缀匹配原则，将会选择这条到达不存在网络的黑洞路由，下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞

![image-20220130162539369](computer_network_hnust.assets/image-20220130162539369.png)



#### 网络故障可能导致的路由环路问题

1，假设路由器R1检测到其接口0所直连的网络出现了故障而不可达，就会自动在其路由表中删除该直连网络的路由条目：

![image-20220130163018728](computer_network_hnust.assets/image-20220130163018728.png)

2，之后R2要转发IP数据报到该网络，进行查表转发，找到匹配的路由条目，下一跳转发给R1的接口1：

![image-20220130163211865](computer_network_hnust.assets/image-20220130163211865.png)

3，R1收到该IP数据报后，进行查表转发，找不到该IP数据报的目的网络的相关路由条目，只能走默认路由，也就是下一跳转发给R2的接口0；这样就把该IP数据报错误地转发给了R2，很显然R1和R2之间产生了路由环路：

![image-20220130163452111](computer_network_hnust.assets/image-20220130163452111.png)

4，针对这种情况，我们可以在R1的路由表中添加针对该直连网络的黑洞路由，

![image-20220130163620532](computer_network_hnust.assets/image-20220130163620532.png)

5，这样当R2要转发IP数据报到该网络时，进行查表转发，找到匹配的路由条目，下一跳转发给R1的接口1：

![image-20220130163748934](computer_network_hnust.assets/image-20220130163748934.png)

6，R1收到该IP数据报后，进行查表转发，找到匹配的路由条目，这是一条黑洞路由，下一跳为虚拟接口null0，因此该IP数据报会进入这个黑洞：

![image-20220130163945192](computer_network_hnust.assets/image-20220130163945192.png)

7，假设一段时间后，之前的故障消失了，则R1又自动地得出了其接口0的直连网络的路由条目，并将我们之前人工配置的针对该直连网络的黑洞路由条目设置为失效状态：

![image-20220130164216032](computer_network_hnust.assets/image-20220130164216032.png)

8，假设R1再次检测到其接口0所直连的网络出现了故障而不可达，则会自动在其路由表中删除该直连网络的路由条目，并将我们之前配置的针对该直连网络的黑洞路由条目设置为生效状态：

![image-20220130164415755](computer_network_hnust.assets/image-20220130164415755.png)



#### 小结

![image-20220130164456299](computer_network_hnust.assets/image-20220130164456299.png)



### 路由选择协议概述

#### 动态路由选择VS静态路由选择

![image-20220130164858001](computer_network_hnust.assets/image-20220130164858001.png)

#### 因特网所采用的路由选择协议的主要特点

![image-20220130165031596](computer_network_hnust.assets/image-20220130165031596.png)

- 自治系统内部和自治系统外部采用不同类别的路由选择协议，分别进行路由选择



#### 因特网采用的分层次路由选择协议实例

1，假设这是因特网中的很小的一部分；我们可以将绿色背景的网络和路由器划归到一个自治系统，将蓝色背景的网络和路由器划归到另一个自治系统；自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择：

![image-20220130165848557](computer_network_hnust.assets/image-20220130165848557.png)

2，域间路由选择使用外部网关协议EGP这个类别的路由选择协议，域内路由选择使用内部网关协议IGP这个类别的路由选择协议：

![image-20220130170558871](computer_network_hnust.assets/image-20220130170558871.png)

- 需要说明的是，外部网关协议EGP和内部网关协议IGP只是路由选择协议的分类名称，而不是具体的路由选择协议。
- 另外，名称中使用的是“网关”这个词，是因为在因特网早期的RFC文档中，没有使用路由器而使用的是“网关”这一名词；现在新的RFC文档中又改用“路由器”这一名词，因此外部网关协议EGP可改称为“外部路由协议ERP”，内部网关协议IGP可改称为“内部路由协议IRP”。本课程仍然采用RFC原先使用的名词，以方便大家查阅RFC文档。

3，在一个自治系统内部使用的具体的内部网关协议，与因特网中其他自治系统中选用何种内部网关协议无关；例如，在绿色背景的自治系统内部使用的内部网关协议为“路由信息协议RIP”，而在蓝色背景自治系统内部使用的内部网关协议为“开放式最短路径优先OSPF协议”，自治系统之间使用的外部网关协议为“边界网关协议BGP”：

![image-20220130170951094](computer_network_hnust.assets/image-20220130170951094.png)



#### 常见的路由选择协议

![image-20220130171136012](computer_network_hnust.assets/image-20220130171136012.png)

#### 路由器的基本结构

1，路由选择协议是在路由器上运行的，所以我们需要了解一下路由器的基本结构。

2，结构如图：

![image-20220130171831657](computer_network_hnust.assets/image-20220130171831657.png)

- 我们不严格区分路由器中的路由表和转发表，这样有助于简化问题的分析，后续也不区分。
- 我：”本内容课程讲了蛮多，配合了ppt动画讲例子，但是我觉得不是重点，故仅存概览图，后续有需要再细学这块。“



#### 小结

![image-20220130172052536](computer_network_hnust.assets/image-20220130172052536.png)





### 路由信息协议RIP的基本工作原理

#### 基本信息

1，

![image-20220130205704088](computer_network_hnust.assets/image-20220130205704088.png)

2，

![image-20220130205947028](computer_network_hnust.assets/image-20220130205947028.png)

- 等价负载均衡：也就是将通信量均衡地分布到多条等价的路由上。



#### RIP的基本工作过程

1，

![image-20220130210436629](computer_network_hnust.assets/image-20220130210436629.png)

2，

![image-20220130210539290](computer_network_hnust.assets/image-20220130210539290.png)

3，

![image-20220130210644271](computer_network_hnust.assets/image-20220130210644271.png)



#### 路由条目更新规则实例

![image-20220130211222874](computer_network_hnust.assets/image-20220130211222874.png)



#### 路由条目更新小练习

1，

![image-20220130211317437](computer_network_hnust.assets/image-20220130211317437.png)2，

![image-20220130211419381](computer_network_hnust.assets/image-20220130211419381.png)



#### RIP存在“坏消息传播得慢”的问题

1，

![image-20220130211634043](computer_network_hnust.assets/image-20220130211634043.png)

2，

![image-20220130211846638](computer_network_hnust.assets/image-20220130211846638.png)

- 请注意，使用上述措施后，也不能彻底避免路由环路问题，这是距离向量算法的本质所决定的。



#### 小结

![image-20220130212010765](computer_network_hnust.assets/image-20220130212010765.png)



### 开放最短路径优先OSPF的基本工作原理

#### 基本概念

![image-20220130212441374](computer_network_hnust.assets/image-20220130212441374.png)



####  链路状态

![image-20220130212729494](computer_network_hnust.assets/image-20220130212729494.png)



#### hello分组

![image-20220130213047834](computer_network_hnust.assets/image-20220130213047834.png)

#### 链路状态通告LSA

1，

![image-20220130213436683](computer_network_hnust.assets/image-20220130213436683.png)

2，

![image-20220130213337189](computer_network_hnust.assets/image-20220130213337189.png)

3，

![image-20220130213739654](computer_network_hnust.assets/image-20220130213739654.png)

#### OSPF分组类型

![image-20220130213857796](computer_network_hnust.assets/image-20220130213857796.png)



#### OSPF的基本工作过程

1，相邻路由器之间周期性发送问候分组，以便建立和维护邻居关系：

![image-20220130214242308](computer_network_hnust.assets/image-20220130214242308.png)

2，建立邻居关系后，给邻居路由器发送数据库描述分组，也就是将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器：

![image-20220130214558261](computer_network_hnust.assets/image-20220130214558261.png)

3，例如R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组：

![image-20220130214802883](computer_network_hnust.assets/image-20220130214802883.png)

4，R2收到后，将R1缺少的链路状态项目的详细信息封装在链路状态更新分组中发送给R1：

![image-20220130214743151](computer_network_hnust.assets/image-20220130214743151.png)

5，R1收到后，将这些所缺少的链路状态项目的详细信息添加到自己的链路状态数据库中，并给R2发送链路状态确认分组：

![image-20220130215156981](computer_network_hnust.assets/image-20220130215156981.png)

6，需要说明的是，R2也可以向R1请求自己所缺少的链路状态项目的详细信息，这里就不再演示该过程了。

7，最终R1和R2的链路状态数据库达成一致，也就是链路状态数据库达到同步：

![image-20220130215440352](computer_network_hnust.assets/image-20220130215440352.png)

8，每30分钟或链路状态发生变化时，路由器都会发送链路状态更新分组；收到该分组的其他路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组；这就叫”新情况下的链路状态数据库同步“：

![image-20220130215745774](computer_network_hnust.assets/image-20220130215745774.png)



#### DR和BDR

![image-20220130220234358](computer_network_hnust.assets/image-20220130220234358.png)



#### 区域(Area)概念

![image-20220130221136859](computer_network_hnust.assets/image-20220130221136859.png)

- 划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个Area，而不是整个自治系统；这样就减少了整个网络上的通信量。
- 如果路由器的所有接口都在同一个区域内，则该路由器称为”区域内路由器“
- 为了本区域和其他边界联通，每个区域都会有一个区域边界路由器；他的一个接口用于连接自身所在区域，另一个接口用于连接主干区域。
- 主干区域内的路由器称为主干路由器，我们也可以把区域边界路由器看作是主干路由器。
- 在主干区域内还要有一个路由器，专门和本自治系统外的其他自治系统交换路由信息；这样的路由器称为“自治系统边界路由器”

- 分层次划分区域的优点缺点：

  - 优点：
    - 使每个区域内部交换路由信息的通信量大大减小，因而使OSPF协议可以用于规模很大的自治系统中。

  - 缺点：
    - 交换信息的种类增多了
    - OSTF协议更复杂了



#### 小结

![image-20220130221432359](computer_network_hnust.assets/image-20220130221432359.png)



### 边界网关协议BGP的基本工作原理

#### 引入

1，

![image-20220131102105689](computer_network_hnust.assets/image-20220131102105689.png)

2，

![image-20220131102303307](computer_network_hnust.assets/image-20220131102303307.png)

3，

![image-20220131102433082](computer_network_hnust.assets/image-20220131102433082.png)

#### BGP工作原理

1,

![image-20220131102633256](computer_network_hnust.assets/image-20220131102633256.png)

2，

![image-20220131102846253](computer_network_hnust.assets/image-20220131102846253.png)



#### BGP发言人交换路径向量例子

1，自治系统AS2的BGP发言人通知主干网的BGP发言人：“要到达网络N1N2N3N4可经过AS2”：

![image-20220131103128144](computer_network_hnust.assets/image-20220131103128144.png)

2，主干网在收到这个通知后，就发出通知：“要到达网络N1N2N3N4，可沿路径(AS1,AS2)”；这里的路径(AS1,AS2)称为路径向量：

![image-20220131103451091](computer_network_hnust.assets/image-20220131103451091.png)

3，自治系统AS3收到这条路径向量信息后，如果AS3自身也包含在其中则不能采用这条路径，否则会兜圈子：

![image-20220131103626812](computer_network_hnust.assets/image-20220131103626812.png)



#### BGP版本四中规定的四种报文

![image-20220131104341374](computer_network_hnust.assets/image-20220131104341374.png)

- 在BGP协议刚运行时，BGP的临站交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部分，这样做对节省网络带宽和减少路由器的处理开销都有好处。



#### 小练习

1，

![image-20220131104512185](computer_network_hnust.assets/image-20220131104512185.png)

2，

![image-20220131104806364](computer_network_hnust.assets/image-20220131104806364.png)

- 没有什么计算过程和解答技巧，记住本图的封装关系即可

- 问：”网络层路由器为什么会有传输层UDP和TCP？“猜测：“传统交换机定义和现代交换机不一样，现代交换机包含了第三层及以上，[参考网址](https://blog.csdn.net/vecloud/article/details/108666569)”



#### 小结

![image-20220131105024869](computer_network_hnust.assets/image-20220131105024869.png)

- 很多细节超出教学范围，有兴趣可以查阅“RFC 4271文档”



### IPv4数据报的首部格式

为了简单起见，之后我们将IPv4数据报简称为IP数据报，而不支出版本号。

IP数据报的首部格式及其内容，是实现IP协议主要功能的基础，因此有必要搞清楚这部分的内容。

#### 首部长度+可选字段+填充

![image-20220131112856924](computer_network_hnust.assets/image-20220131112856924.png)

- 首部长度：首部长度字段是以4字节为单位的，换句话说，IP数据报的首部长度一定是4字节的整数倍；每一行32比特，对应4个字节。首部最小取5行，对应首部固定部分20字节；首部最大取15行，对应首部固定20字节+可变40字节。

- 填充字段：首部末尾填充0，确保”首部长度“是4字节的整数倍。

#### 区分服务

![image-20220131113212538](computer_network_hnust.assets/image-20220131113212538.png)

#### 总长度

![image-20220131114858228](computer_network_hnust.assets/image-20220131114858228.png)

- 实际应用中，很少传65535字节这么长的IP数据报
- ”首部长度字段“和“总长度字段”的区别，以及根据”首部长度字段“和“总长度字段”的值计算数据载荷，见本图。
  - 总长度是以字节为单位，首部长度是以4字节为单位。



#### 标识+标志+片偏移

1，”标识+标志+片偏移“共同用于IP数据报分片：

![image-20220131115850166](computer_network_hnust.assets/image-20220131115850166.png)

2，这是网际层封装出的IP数据报：

![image-20220131115926610](computer_network_hnust.assets/image-20220131115926610.png)

3，它将在数据链路层封装成帧：

![image-20220131120004050](computer_network_hnust.assets/image-20220131120004050.png)

4，每一种数据链路层协议都规定了帧的数据载荷的最大长度，称为最大传输单元MTU；例如，以太网的数据链路层规定MTU的值为1500字节，如果某个IP数据报的总长度超过MTU时，将无法封装成帧，需要将原IP数据报分片为更小的IP数据报，再将各分片IP数据报封装成帧：

![image-20220131121651361](computer_network_hnust.assets/image-20220131121651361.png)

5，三个字段的分别功能：

![image-20220131122302882](computer_network_hnust.assets/image-20220131122302882.png)





#### 对IPv4数据报分片实例

1，假设有这样一个IP数据报，它由20字节的固定首部和3800字节的数据载荷两部分构成；也就是说，该IP数据报的总长为3820字节：

![image-20220131134423192](computer_network_hnust.assets/image-20220131134423192.png)

2，假设使用以太网传送该ip数据报，以太网的最大传送单元MTU为1500字节，也就是以太网的数据载荷部分最大为1500字节，无法承装3820字节长的IP数据报；因此需要把该IP数据报分片成几个更小的IP数据报，每个长度不能大于1500字节；然后再将每个分片IP数据报封装成一个以太网帧进行传输。

- 为了更好得描述后续的分片工作，我们将原IP数据报数据载荷部分的每一个字节都编上号，第一个字节编号为0，最后一个字节编号为3799；

3，我们可将原IP数据报的数据载荷分成三个更小的分片，第一个分片从0号字节到1399字节，共1400字节；第二个分片从1400号字节到2799号字节，共1400字节；第三个分片从2800号字节到3799号字节，共1000个字节；分片结束后，给每个分片重新添加一个首部，使之成为IP数据报：

![image-20220131135208340](computer_network_hnust.assets/image-20220131135208340.png)

4，思考：给各分片添加的首部是否完全相同呢？来填一下下面这张表格：

![image-20220131135305125](computer_network_hnust.assets/image-20220131135305125.png)

- 原IP数据报首部中的总长度字段的十进制取值为3800+20；表示字段的十进制取为12345；MF比特的取值为0，表示后面没有分片数据报，这就是最后一个分片数据报；DF比特的取值为0，表示该IP数据报允许被分片；由于这是未分片的原IP数据报，因此片偏移为0。

5，我们来填写分片1 IP数据报首部中相关字段的值：

![image-20220131140507474](computer_network_hnust.assets/image-20220131140507474.png)

- 总长度字段的十进制取值为1400+20，其中1400字节是分片的长度，20字节是固定首部的长度；
- 标识字段的十进制取值与原IP数据报的相同；
- 由于该分片不是最后一个分片，因此MF比特的取值为1，表示该分片后还有分片；
- 该分片IP数据报允许被再次分片，因此DF比特的取值为0；
- 该分片IP数据报数据载荷部分的第一个字节，就是原IP数据报数据载荷部分的第一个字节，因此片偏移字段的取值为"0/8"，除以8的原因是片偏移字段以8字节为单位

6，同理，填写分片2IP数据报首部中相关字段的值：

![image-20220131140808101](computer_network_hnust.assets/image-20220131140808101.png)

- 分片2IP数据报首部中这几个相关字段的值，只有“片偏移”字段的值与分片1 IP数据报的值不同。

7，同理，填写分片3IP数据报首部中相关字段的值：

![image-20220131141259588](computer_network_hnust.assets/image-20220131141259588.png)

- 总长度字段的十进制取值为1000+20，其中1000字节是分片的长度，20字节是固定首部的长度；
- 标识字段的十进制取值与原IP数据报的相同；
- 由于该分片就是最后一个分片，因此MF比特的取值为0，表示该分片后没有其他分片；
- 该分片IP数据报允许被再次分片，因此DF比特的取值为0；
- 该分片IP数据报数据载荷的第一个字节，是原IP数据报数据载荷中编号为2800的字节，因此片偏移字段的取值为2800/8.

8，现在假定分片2的数据报经过某个网络时需要再进行分片，其中一个分片长度为800字节，另一个分片长度为600字节；分片结束后，给每个分片重新添加一个首部，使之成为IP数据报；接下来请填写该表格，相信大家都可以正确完成：

![image-20220131141557024](computer_network_hnust.assets/image-20220131141557024.png)



#### 生存时间

1，概念

![image-20220131144447218](computer_network_hnust.assets/image-20220131144447218.png)

2，生存时间可以防止IP数据报在网络中永久兜圈：

![image-20220131144724496](computer_network_hnust.assets/image-20220131144724496.png)

- 错误配置下一跳的话，如果没有TTL，IP数据报会永远兜圈

#### 协议字段

![image-20220131144925500](computer_network_hnust.assets/image-20220131144925500.png)

#### 首部检验和

![image-20220131145145766](computer_network_hnust.assets/image-20220131145145766.png)

#### 源IP地址+目的IP地址

![image-20220131145224556](computer_network_hnust.assets/image-20220131145224556.png)

#### 小练习 

1，

![image-20220131145646392](computer_network_hnust.assets/image-20220131145646392.png)

![image-20220131145715708](computer_network_hnust.assets/image-20220131145715708.png)

- MTU是网络层最大传输单元，包含IP数据报的首部，但不包括数据链路层的帧头

2，题目：

![image-20220131150144361](computer_network_hnust.assets/image-20220131150144361.png)

web服务其的IP地址就填写在IP分组头中的目的IP地址字段，IP分组还要封装成以太网帧才能发送：

![image-20220131150323903](computer_network_hnust.assets/image-20220131150323903.png)

在IP分组头中，目的IP地址字段前还有16个字节的内容；在以太网帧中，数据载荷前还有14字节的内容；因此可知，在以太网帧中，从第31个字节开始的4个字节实际上就是目的IP地址的内容：

![image-20220131150759370](computer_network_hnust.assets/image-20220131150759370.png)

- 题目所给的以太网帧的第一列数据，实际上并不是以太网帧的内容，仅仅作为行号，其增量是16，表示每行有16个字节的内容。
- 以太网帧内容的十六进制形式，和ASCII形式内容如图。

从图中可知，主机的默认网关就是路由器R；而目的MAC地址字段就是以太网帧的前6个字节，其内容就是默认网关的MAC地址：

![image-20220131151133008](computer_network_hnust.assets/image-20220131151133008.png)

至于(4)问的修改字段如本图所示：

![image-20220131151221810](computer_network_hnust.assets/image-20220131151221810.png)



#### 小结

![image-20220131151322065](computer_network_hnust.assets/image-20220131151322065.png)



### 网际控制报文协议ICMP

#### 基本信息

1，ICMP是什么：

![image-20220201155629802](computer_network_hnust.assets/image-20220201155629802.png)

2，ICMP差错报告报文共有五种方式：

![image-20220201155758720](computer_network_hnust.assets/image-20220201155758720.png)

3，ICMP询问报文有两种：

- 回送请求和回答
- 时间戳请求和回答



#### 差错报告报文详解

1，终点不可达

![image-20220201155925161](computer_network_hnust.assets/image-20220201155925161.png)

2，源点抑制

路由器拥塞：

![image-20220201160013895](computer_network_hnust.assets/image-20220201160013895.png)

主机拥塞：

![image-20220201160103599](computer_network_hnust.assets/image-20220201160103599.png)



3，时间超过

![image-20220201160421261](computer_network_hnust.assets/image-20220201160421261.png)

4，参数问题

![image-20220201160510694](computer_network_hnust.assets/image-20220201160510694.png)

5，改变路由

![image-20220201160618851](computer_network_hnust.assets/image-20220201160618851.png)

6，不应该发送ICMP差错报告报文的情况

![image-20220201160724233](computer_network_hnust.assets/image-20220201160724233.png)

#### 询问报文详解

![image-20220201161135609](computer_network_hnust.assets/image-20220201161135609.png)



#### ICMP应用举例-分组网间探测PING

![image-20220201161902596](computer_network_hnust.assets/image-20220201161902596.png)

- 十分常用的ping命令！！！

#### ICMP应用举例-跟踪路由

1，概念：

![image-20220201162225722](computer_network_hnust.assets/image-20220201162225722.png)

2，实例：

![image-20220201162300597](computer_network_hnust.assets/image-20220201162300597.png)

3，思考：tracert命令的实现原理是什么？：

假设主机H1想知道要到达主机H2要经过哪些路由器，H1就给H2发送ICMP回送请求报文；该报文被封装在IP数据报中,IP数据报首部中生存时间字段TTL的值被设置为1：

<img src="computer_network_hnust.assets/image-20220201162918762.png" alt="image-20220201162918762" style="zoom:50%;" />



该IP数据报到达R1后，其生存时间减一结果为0；R1丢弃该数据报并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过，H1就知道了到达H2的路径中的第一个路由器：

<img src="computer_network_hnust.assets/image-20220201163220292.png" alt="image-20220201163220292" style="zoom:50%;" />

H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为2：

<img src="computer_network_hnust.assets/image-20220201163352626.png" alt="image-20220201163352626" style="zoom:50%;" />

经过R1转发后，该数据报的生存时间减少为1；该IP数据报到达R2后，其生存时间减1结果为0；R2丢弃该数据报并向发送该数据报的源主机H1发送ICMP差错报告报文，其类型为时间超过；这样H1就知道了到达H2的路径中的第二个路由器：

<img src="computer_network_hnust.assets/image-20220201163621781.png" alt="image-20220201163621781" style="zoom:50%;" />

H1继续发送下一个封装有ICMP回送请求报文的IP数据报，其首部中生存时间字段TTL的值被设置为3：

<img src="computer_network_hnust.assets/image-20220201163742442.png" alt="image-20220201163742442" style="zoom:50%;" />

经过R1和R2的转发后，该数据报到达主机H2，其生存时间减少为1；H2解析该数据报，发现其内部封装的是ICMP回送请求报文，于是就给H1发送封装有ICMP回送请求回答报文的IP数据报；这样H1就知道已经跟踪到路径中的最后一站也就是目的主机H2：

<img src="computer_network_hnust.assets/image-20220201164111784.png" alt="image-20220201164111784" style="zoom:50%;" />



#### 小结

![image-20220201164147852](computer_network_hnust.assets/image-20220201164147852.png)

### 虚拟专用网VPN与网络地址转换NAT

#### 虚拟专用网实例

1，假设某机构部门A的局域网位于北京，该机构部门B的局域网位于上海，那么如何才能让这两个专用网络可以通信呢？

![image-20220201171400619](computer_network_hnust.assets/image-20220201171400619.png)

2，一种方式是租用电信公司的通信线路；此方法简单方便，但是租金很高：

![image-20220201171542542](computer_network_hnust.assets/image-20220201171542542.png)

3，另一种方法是**利用公用的因特网**，作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。

![image-20220201171703111](computer_network_hnust.assets/image-20220201171703111.png)

4，那么虚拟专用网中的各主机应该分配怎样的IP地址呢？由于IPv4地址的紧缺，一个机构能够申请到的IPv4地址数量往往远小于本机构所拥有的主机数量。**因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址**，而不是需要申请的、在因特网上使用的公有地址：

![image-20220201171918787](computer_network_hnust.assets/image-20220201171918787.png)

5，我们可以在因特网数字分配机构IANA的官方网站，查看IPv4地址空间中特殊地址的分配方案；这三个地址块中的地址就是无需申请的可自由分配的专用地址(或称私有地址)：

![image-20220201172130007](computer_network_hnust.assets/image-20220201172130007.png)

6，我们给部门A的专用网分配的私有地址的网络号为10.1.0.0，给部门B的专用网分配的私有地址的网络号为10.2.0.0；两个专用网中各主机所分配的私有地址如图所示：

![image-20220201172333377](computer_network_hnust.assets/image-20220201172333377.png)

- 需要**注意**的是：私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信；换句话说，私有地址只能用作本地地址而不能用作全球地址；在因特网中的所有路由器对目的地址是私有地址的IP数据报一律不进行转发。

7，很显然部门A和B各自至少需要一个路由器具有合法的全球IP地址，这样他们各自的专用网才能利用公有的因特网进行通信；合法全球IP地址如图：

![image-20220201172722606](computer_network_hnust.assets/image-20220201172722606.png)

8，假设部门A中的这台主机要给部门B中的另一台主机发送数据，他会将待发送数据封装成内部IP数据报发送给路由器R1；其首部中源地址字段的值为部门A中该主机的IP地址，目的地址字段的值为部门B中另一台主机的IP地址:

![image-20220201173230669](computer_network_hnust.assets/image-20220201173230669.png)

9，R1收到该数据报后，发现其目的网络必须通过因特网才能到达，就将该内部IP数据报进行加密，这样就确保了内部IP数据报的安全；然后重新添加上数据报的首部，封装称为在因特网上发送的外部数据报，其首部中源地址字段的值为路由器R1的全球地址，目的地址字段的值为路由器R2的全球地址:

![image-20220201173700477](computer_network_hnust.assets/image-20220201173700477.png)

10，路由器R2收到该外部数据报后，去掉其首部，将其数据部分进行解密，恢复出原来的内部IP数据报，这样就可以从其首部提取出源地址和目的地址；根据目的地址将该内部IP数据报发送给相应的主机：

![image-20220201174001580](computer_network_hnust.assets/image-20220201174001580.png)

11，很显然，两个专用网内的主机间发送的数据报是通过了共用的因特网，但在效果上就好像是在本机构的专用网上传送一样。

12，数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看R1和R2之间好像是一条直通的点对点链路，因此也被称为”IP隧道技术“：

![image-20220201174302007](computer_network_hnust.assets/image-20220201174302007.png)

13，其他信息：

- 如上图所示，同一机构内不同部门的内部网络所构成的虚拟专用网VPN又称为内联网VPN。
- 有时一个机构的VPN需要有某些外部机构（通常就是合作伙伴）参加进来。这样的VPN就称为外联网VPN。
- 在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工PC中的VPN软件，在员工的PC和公司的主机之间建立VPN隧道，即可访问专用网络中的资源。这种VPN称为远程接入VPN。
  - 比如寒暑假在家想登录学校教务系统，就得用学校的VPN。



#### 网络地址转换NAT的基本工作原理

1，网络地址转换NAT(Network Address Translation)：

- 虽然因特网采用了无分类编址方式来减缓IPv4地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4地址空间即将面临耗尽的危险仍然没有被解除。
- 1994年提出了一种网络地址转换NAT的方法再次**缓解了IPv4地址空间即将耗尽的问题**。
- NAT能使大量**使用内部专用地址的专用网络用户共享少量外部全球地址来访问因特网上的主机和资源。**

2，图中的专用网络号使用192.168.0.0，该网络中各主机的私有地址如图所示；那么使用私有地址的主机如何才能与因特网上使用全球IP地址的主机进行通信呢：

![image-20220201214704808](computer_network_hnust.assets/image-20220201214704808.png)

3，这需要在专用网络连接到因特网的路由器上安装NAT软件，拥有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址；这样所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换成全球IP地址：

![image-20220201214958554](computer_network_hnust.assets/image-20220201214958554.png)

4，我们来举例说明，假设使用私有地址的该主机，要给因特网上使用全球IP地址的另一台主机发送IP数据报：

![image-20220201215129094](computer_network_hnust.assets/image-20220201215129094.png)

5，该主机将数据报发送给NAT路由器，数据报首部中源地址字段的值为该主机的私有地址，目的地址字段的值为因特网上另一台主机的全球地址；NAT路由器从自己的全球IP地址池中为该主机分配一个临时的全球IP地址172.38.1.5，并将IP数据报的源地址修改为该地址；然后将私有地址与全球地址的对应关系记录在NAT转换表中，之后就可以转发该IP数据报了：

![image-20220201215551175](computer_network_hnust.assets/image-20220201215551175.png)

6，请注意，此时IP数据报中的源地址和目的地址都是全球IP地址，如图所示：

![image-20220201215708581](computer_network_hnust.assets/image-20220201215708581.png)

7，因特网上的这台主机给源主机发回数据报，数据报的源地址和目的地址都是全球IP地址，如图所示：

![image-20220201215819314](computer_network_hnust.assets/image-20220201215819314.png)

8，NAT路由器收到该IP数据报后，在NAT转换表中进行查找，发现该数据报的目的地址所对应的私有地址为192.168.0.2，于是就将该IP数据报的目的地址修改为192.168.0.2，并将其发送给相应的主机；请注意，此时IP数据报中的源地址为因特网上那台主机的全球IP地址，而目的地址为专用网中这台主机的私有地址：

![image-20220201220143481](computer_network_hnust.assets/image-20220201220143481.png)

9，如图所示，当专用网中的这两台使用私有地址的主机都要给因特网上使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与两个全球地址的对应关系：

![image-20220201220348064](computer_network_hnust.assets/image-20220201220348064.png)

10，这种基本转换方法存在这样一个问题：**如果NAT路由器具有N个全球IP地址，那么至多只能有N个内网主机能够同时和因特网上的主机通信**。

- 由于绝大多数的网络应用都是使用运输层协议TCP或UDP来传送数据，因此可以利用运输层的端口号和IP地址一起进行转换。这样，**用一个全球IP地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信**。这种将端口号和IP地址一起进行转换的技术叫作**网络地址与端口号转换NAPT**(Network Address and Port Translation)。

11，如图所示，这是本例中的NAPT路由器，它的全球IP地址，他的NAPT转换表中的部分内容：

![image-20220201221001994](computer_network_hnust.assets/image-20220201221001994.png)

- 实际上现在很多家用路由器都是这种NAPT路由器，由于端口号的概念属于运输层，而我们的课程还没有进行到运输层，因此对该转换表中的内容不再解释；等学习了运输层的端口号概念后，相信就很容易看懂该转换表的内容。

12，请大家思考一个问题：内网主机与外网主机之间的通信是否能由外网主机首先发起？答案是“否定的”：

![image-20220201221303612](computer_network_hnust.assets/image-20220201221303612.png)

13，如果由外网主机首先发起，那么当NAPT路由器收到来自外网的IP数据报后，在NAPT转换表中找不到相应的记录，也就无法把数据报转发给内网中的主机；因此使用私有地址的主机不能直接充当因特网服务器：

![image-20220201221459175](computer_network_hnust.assets/image-20220201221459175.png)

- 对于一些P2P(点对点)网络应用，需要**外网主机主动与内网主机进行通信**，在通过NAT时会遇到问题，需要网络应用自己使用一些特殊的**NAT穿越技术**来解决问题。
- 另外，由于NAT对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的**安全保护**。

14，上节课介绍的ICMP协议的典型应用tracert，可以看到其中两个路由器使用了相同的IP地址；这很可能内网出外网的路由器使用了NAT，且内网中还有一个使用私有IP地址的路由器：

![image-20220201221837831](computer_network_hnust.assets/image-20220201221837831.png)



#### 小结

![image-20220201221910410](computer_network_hnust.assets/image-20220201221910410.png)



## 运输层

### 运输层概述

#### 基本信息

![image-20220202120611762](computer_network_hnust.assets/image-20220202120611762.png)



#### 从计算机网络体系结构的角度看运输层

1，AP1和AP2和AP3和AP4是通信双方应用层中的应用进程；假设AP1与AP4之间进行基于网络的通信，AP2与AP3之间进行基于网络的通信；在运输层使用不同的端口来对应不同的应用进程，然后通过网络层及其下层来传输应用层报文：

![image-20220202121107274](computer_network_hnust.assets/image-20220202121107274.png)

2，接收方的运输层通过不同的端口，将收到的应用层报文交付给应用层中相应的应用进程：

![image-20220202121707280](computer_network_hnust.assets/image-20220202121707280.png)

- 需要注意的是，这里的**端口**并不是指看得见摸得着的物理端口，而是指用来区分不同应用进程的标识符；为了简单起见，在学习和研究运输层时，我们可以简单地认为，运输层直接为应用进程间的逻辑通信提供服务。
- 逻辑通信的意思是：运输层之间的通信，好像是沿水平方向传送数据；但事实上这两个运输层之间并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的；运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等)，它使应用进程看见的就**好像是在两个运输层实体之间有一条端到端的逻辑通信信道**。

3，根据应用需求的不同，**因特网的运输层**为应用层提供了两种不同的运输协议，即**面向连接的TCP**和**无连接的UDP**，这两种协议就是本章要讨论的主要内容。



#### 小结

![image-20220202121957313](computer_network_hnust.assets/image-20220202121957313.png)



### 运输层端口号，复用与分用的概念

#### 端口号概念

![image-20220202135601403](computer_network_hnust.assets/image-20220202135601403.png)

- 主要是因为进程标识符在各系统上不一样，故运输层使用端口号来区分应用层的不同应用进程。



#### 发送方的复用和接收方的分用

1，这是收发双方的应用进程：

![image-20220202140250683](computer_network_hnust.assets/image-20220202140250683.png)

2，发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，这称为UDP复用；而另一些应用进程所发送的不同应用报文，在运输层使用TCP协议进行封装，这称为TCP复用；运输层使用端口号来区分不同的应用进程：

![image-20220202140441312](computer_network_hnust.assets/image-20220202140441312.png)

3，不管是使用运输层的UDP协议封装成的UDP用户数据报，还是使用TCP协议封装成的TCP报文段，在网络层都需要使用IP协议封装成IP数据报，这称为IP复用：

![image-20220202140618437](computer_network_hnust.assets/image-20220202140618437.png)

4，IP数据报首部中协议字段的值用来表明IP数据报的数据载荷部分封装的是何种协议数据单元，取值为6表示封装的是TCP报文段，取值为17表示封装的是UDP用户数据报：

![image-20220202140857746](computer_network_hnust.assets/image-20220202140857746.png)

5，接收方的网络层收到IP数据报后进行IP分用；若IP数据报首部中协议字段的值为17，则把IP数据报的数据载荷部分所封装的UDP用户数据报上交运输层的UDP；若协议字段的值为6，则把IP数据报的数据载荷部分所封装的TCP报文段上交运输层的TCP：

![image-20220202141142468](computer_network_hnust.assets/image-20220202141142468.png)

6，运输层对UDP用户数据报进行UDP分用，对TCP报文段进行TCP分用；也就是根据端口号将他们交付给上层相应的应用进程：

![image-20220202141328512](computer_network_hnust.assets/image-20220202141328512.png)



#### TCP/IP体系的应用层常用协议所使用的运输层熟知端口号

![image-20220202141626573](computer_network_hnust.assets/image-20220202141626573.png)

- 不管在运输层使用TCP还是UDP协议，在网络层都需要使用IP协议；IP数据报首部中协议字段的值，表明了IP数据报数据载荷部分封装的是何种协议单元。



#### 运输层端口号的作用实例

也描绘了浏览器请求网页的过程中，在传输层发生了什么。



1，如图所示，用户PC，DNS服务器，Web服务器通过交换机进行互联，他们属于同一个以太网中：

![image-20220202142949135](computer_network_hnust.assets/image-20220202142949135.png)

2，假设这是Web服务器的域名，DNS服务器中记录有该域名所对应的IP地址：

![image-20220202143120754](computer_network_hnust.assets/image-20220202143120754.png)

3，我们在用户PC中使用网页浏览器来访问WEB服务器的内容，在网页浏览器的地址栏中属于web服务器得域名；用户PC中的DNS客户端进程会发送一个DNS查询请求报文，其内容为“域名www.porttest.com所应的地址是什么?”：

![image-20220202143413375](computer_network_hnust.assets/image-20220202143413375.png)

4，DNS查询请求报文需要使用运输层的UDP协议，封装成UDP用户数据报；其首部中的源端口字段的值在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程，例如49152；其首部中目的端口字段的值设置为53，这是DNS服务器端进程所使用的熟知端口号：

![image-20220202143942035](computer_network_hnust.assets/image-20220202143942035.png)

5，之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器：

![image-20220202144057027](computer_network_hnust.assets/image-20220202144057027.png)

6，DNS服务器收到该数据报后，从中解封出UDP用户数据报；UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程：

![image-20220202144308689](computer_network_hnust.assets/image-20220202144308689.png)

7，DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址；之后会给用户PC发送DNS相应报文，其内容为“域名www.porttest.com所应的地址是192.168.0.3”：

![image-20220202144618216](computer_network_hnust.assets/image-20220202144618216.png)

8，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报；其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报；目的端口字段的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号：

![image-20220202144900041](computer_network_hnust.assets/image-20220202144900041.png)

9，之后将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC：

![image-20220202145046574](computer_network_hnust.assets/image-20220202145046574.png)

10，用户PC收到该数据报后，从中解封出UDP用户数据报；UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分也就是DNS相应报文交付给用户PC中的DNS客户端进程：

![image-20220202145324662](computer_network_hnust.assets/image-20220202145324662.png)

11，DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的web服务器的域名所对应的IP地址为192.168.0.3：

![image-20220202145457162](computer_network_hnust.assets/image-20220202145457162.png)

12，现在，用户pc中的HTTP客户端进程可以向web服务器发送HTTP请求报文了，其内容为“首页内容是什么”：

![image-20220202145915686](computer_network_hnust.assets/image-20220202145915686.png)

13，HTTP请求报文需要使用运输层的TCP协议封装成TCP报文段；其首部的源端口字段的值在短暂端口号49151~65535中挑选一个未被占用的，用来表示HTTP客户端进程，例如仍然使用之前用过的49152；其首部目的端口字段的值设置为80，这是HTTP服务器端进程所使用的熟知端口号：

![image-20220202150822597](computer_network_hnust.assets/image-20220202150822597.png)

14，之后将TCP报文段封装在IP数据报中，通过以太网发送给WEB服务器：

![image-20220202150914661](computer_network_hnust.assets/image-20220202150914661.png)

15，WEB服务器收到该数据报后，从中解封出TCP报文段，TCP首部中的目的端口号为80，这表明应将该TCP报文段的数据载荷部分也就是HTTP请求报文交付给本服务器中的HTTP服务器端进程；HTTP服务器端进程解析HTTP请求报文的内容，然后按要求查找首页内容：

![image-20220202151409570](computer_network_hnust.assets/image-20220202151409570.png)

16，之后会给用户PC发送HTTP相应报文，其内容是HTTP客户端所请求的首页内容；HTTP相应报文需要使用运输层的TCP协议封装成TCP报文段，其首部中的源端口字段的值设置为熟知端口号80，表明这是HTTP服务器端进程所发送的TCP报文段；目的端口字段的值设置为49152，这是之前用户PC中发送HTTP请求报文的HTTP客户端进程所使用的短暂端口号：

![image-20220202151805219](computer_network_hnust.assets/image-20220202151805219.png)

17，之后将TCP报文段封装在IP数据报中，通过以太网发送给用户PC：



![image-20220202151908125](computer_network_hnust.assets/image-20220202151908125.png)

18，用户PC收到该数据报后，从中解封出TCP报文段；TCP首部中的目的端口号为49152，这表明应该将该TCP保温段的数据载荷部分也就是HTTP相应报文交付给用户PC中的HTTP客户端进程；HTTP客户端进程解析HTTP响应报文的内容，并在网页浏览器中进行显示：

![image-20220202152309325](computer_network_hnust.assets/image-20220202152309325.png)

19，这样我们就可以在网页浏览器中看到web服务器所提供的首页内容了。



#### 小结

![image-20220202152340194](computer_network_hnust.assets/image-20220202152340194.png)

### UDP和TCP的对比

#### TCP/IP体系结构中TCP和UDP的位置

![image-20220202170940311](computer_network_hnust.assets/image-20220202170940311.png)

- TCP/IP体系结构应用层中的某些协议需要使用运输层的TCP提供的服务，而另一些协议需要使用运输层的UDP提供的服务，



#### TCP和UDP连接方式对比

![image-20220202171322634](computer_network_hnust.assets/image-20220202171322634.png)

- ”三报文握手“和”四报文挥手“属于TCP的连接管理，过程比较复杂，后续课程中会专门介绍。
- 需要注意的是，这里所谓的连接是指“逻辑连接关系”，而不是物理连接。



#### TCP和UDP传播方式对比

1，这是某个局域网上的使用UDP协议通信的四台主机；其中任何一台主机都可向其他三台主机发送广播：

![image-20220202171555679](computer_network_hnust.assets/image-20220202171555679.png)

2，也可以向某个多播组发送多播：

![image-20220202171627628](computer_network_hnust.assets/image-20220202171627628.png)

3，还可以向某台主机发送单播：

![image-20220202171650668](computer_network_hnust.assets/image-20220202171650668.png)

4，也就是说UDP支持单播多播和广播，换句话说即UDP支持”一对一，一对多，一对全“的通信：

![image-20220202171803798](computer_network_hnust.assets/image-20220202171803798.png)

5，再看使用TCP协议的情况，使用TCP协议的通信双方在进行数据传输之前，必须使用三报文握手来建立TCP连接：

![image-20220202171927854](computer_network_hnust.assets/image-20220202171927854.png)

6，TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道；通信双方使用这条基于TCP连接的可靠信道进行通信：

![image-20220202172053554](computer_network_hnust.assets/image-20220202172053554.png)

7，很显然TCP仅支持单播，也就是一对一的通信：

![image-20220202172133156](computer_network_hnust.assets/image-20220202172133156.png)

#### TCP与UDP对应用报文的处理对比



1，先看使用UDP协议的情况，发送方的进程将应用层报文交付给运输层的UDP：

![image-20220202172519895](computer_network_hnust.assets/image-20220202172519895.png)

2，UDP直接给应用层的报文添加一个UDP首部，使之成为UDP用户数据报，然后进行发送：

![image-20220202172629550](computer_network_hnust.assets/image-20220202172629550.png)

- 需要说明的是，为了简单起见，我们忽略运输层下面的各层处理。

3，接收方的UDP收到该UDP用户数据报后：

![image-20220202172749719](computer_network_hnust.assets/image-20220202172749719.png)

4，去掉UDP首部：

![image-20220202172836158](computer_network_hnust.assets/image-20220202172836158.png)

5，将应用层报文交付给应用进程：

![image-20220202172903653](computer_network_hnust.assets/image-20220202172903653.png)

6，也就是说，**UDP**对应用层进程交下来的报文**既不合并也不拆分**，而是保留这些报文的边界；换句话说，**UDP是面向应用报文的**：

![image-20220202173023169](computer_network_hnust.assets/image-20220202173023169.png)

7，再来看使用TCP协议的情况，发送方的TCP把应用进程交付下来的数据块，仅仅看做是一连串的无结构的字节流：

![image-20220202173629156](computer_network_hnust.assets/image-20220202173629156.png)

8，TCP并不知道这些待传送的字节流的含义，仅将他们编号，并存储在自己的发送缓存中：

![image-20220202173643308](computer_network_hnust.assets/image-20220202173643308.png)

9，TCP根据发送策略，从发送缓存中提取一定数量的字节，构建TCP报文段并发送：

![image-20220202173904904](computer_network_hnust.assets/image-20220202173904904.png)

10，接收方的TCP一方面从接收到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程：

![image-20220202174128840](computer_network_hnust.assets/image-20220202174128840.png)

- TCP不保证接收方应用进程所收到的数据块，与发送方进程所发出的数据块具有对应大小的关系；但接收方应用进程收到的字节流，必须和发送方应用进程发出的字节流完全一致
  - 例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付给了上层的应用进程。
  - 即发送方和接收方的主机上面的TCP协议分数据块大小可能不一样而已，同样的一段字节流，一个分的块小一点，一个分的块大一点而已。

11，当然，接收方的应用进程必须有能力识别收到的字节流，把他还原成有意义的应用层数据；也就是说，**TCP是面向字节流的**，这正是TCP实现”可靠传输，流量控制，以及拥塞控制“的基础：

![image-20220202174702219](computer_network_hnust.assets/image-20220202174702219.png)

- 需要说明的是，为了突出示意图的要点，我们只画出了一个方向的数据流；在实际网络中，基于TCP连接的两端可以同时进行TCP报文段的发送和接收，也就是全双工通信。
- 另外，图中TCP保温段的数据部分只包含了几个字节，实际当中，一个TCP报文段包含上千个字节是很常见的。
- 网友：“图中有个小问题，右下角应该是876的数据块，整体就形成了一个数据流”。



#### TCP和UDP可靠性对比

1，UDP提供不可靠服务：

![image-20220202175749119](computer_network_hnust.assets/image-20220202175749119.png)



2，传输层使用TCP协议时，尽管网际层中的IP协议向上层提供的是无连接不可靠的传输服务，也就是说IP数据报可能在传输过程中出现丢失或误码：

![image-20220202175939712](computer_network_hnust.assets/image-20220202175939712.png)

3，但只要运输层使用TCP协议，就可向其上层提供面向连接的可靠传输服务；我们可将其想象成，使用TCP协议的收发双方基于TCP连接的可靠信道进行数据传输：

![image-20220202180154890](computer_network_hnust.assets/image-20220202180154890.png)

#### TCP和UDP首部对比

1，—个UDP用户数据报由首部和数据载荷两部分构成；UDP首部仅有四个字段，每个字段长度为2字节；由于UDP不提供可靠传输服务，它仅仅在网际层的基础上添加了用于区分应用进程的端口，因此他的首部非常简单，仅有8个字节：

![image-20220202180529832](computer_network_hnust.assets/image-20220202180529832.png)

2，一个TCP报文段由首部和数据载荷两部分构成；其首部比UDP用户数据报的首部复杂很多，首部最小20字节，最大60字节，这是因为TCP要实现“可靠传输，流量控制，拥塞控制”等服务，其首部自然会比较复杂，首部中的字段比较多，首部长度也比较长：

![image-20220202180944741](computer_network_hnust.assets/image-20220202180944741.png)



#### 小结

![image-20220202181112780](computer_network_hnust.assets/image-20220202181112780.png)

- 需要说明的是，TCP的流量控制和拥塞控制比较复杂，本节课没介绍，会在后续课程中介绍



### TCP的流量控制

#### 概念

![image-20220202201102172](computer_network_hnust.assets/image-20220202201102172.png)

#### 实例

1，假设主机A和B是因特网上的两台主机，他们已经建立了TCP连接；A给B发送数据，B对A进行流量控制：

![image-20220202202616266](computer_network_hnust.assets/image-20220202202616266.png)

2，这是主机A中待发送数据的字节序号；假设主机A发送的每个TCP报文段可携带100字节数据，因此图中每个小格子表示100字节数据的序号：

![image-20220202202741559](computer_network_hnust.assets/image-20220202202741559.png)

3，在主机A和B建立TCP连接时，B告诉A：“我的接收窗口为400”，因此主机A将自己的窗口也设置为400；这意味着主机A在未收到主机B发来的确认时，可将序号落入发送窗口中的全部数据发送出去。

4，主机A将发送窗口内序号1~100的数据封装成一个TCP报文段发送出去，发送窗口内还有300字节可以发送：

![image-20220202203315707](computer_network_hnust.assets/image-20220202203315707.png)

- seq：是tcp保温段首部中的序号字段，取值1表示TCP报文段数据载荷的第一个字节的序号是1。
- DATA：表示这是TCP数据报文段。



5，主机A将发送窗口内序号101~200的数据封装成一个TCP报文段发送出去，发送窗口内还有200字节可以发送：

![image-20220202203452703](computer_network_hnust.assets/image-20220202203452703.png)

6，主机A将发送窗口内序号201~300的数据封装成一个TCP报文段发送出去，但该报文段在传输过程中丢失了，发送窗口内还有100字节可以发送：

![image-20220202203549134](computer_network_hnust.assets/image-20220202203549134.png)

7，主机B对主机A所发送的201号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为300(即对主机A进行流量控制)：

![image-20220202204126545](computer_network_hnust.assets/image-20220202204126545.png)

- ACK：是TCP报文段首部中的标志位，取值1表示这是一个TCP确认报文段；
- ack：是TCP报文段首部中的确认号字段，取值201表示序号201之前的数据已被全部正确接收，现在希望收到201及其后续的数据；
- rwnd：是TCP报文段首部中的窗口字段，取值300表示自己的接收窗口大小为300

8，主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移除发送窗口；由于主机B在该累计确认中将自己的接收窗口调整为了300，因此主机A相应的将自己的发送窗口调整为300：

![image-20220202204412685](computer_network_hnust.assets/image-20220202204412685.png)

- 目前主机A发送窗口内的序号为201~500，也就是主机A还可以发送这300字节；
  - 其中201~300号字节是已发送的数据，若重传计时器超时，他们会被重传；
  - 301~400号字节已经401~500号字节还未被发送，可被分别封装在一个TCP报文段中发送。

10，主机A现在可将发送缓存中序号1~200的字节数据全部删除了，因为已经收到了主机B对它们的累计确认：

![image-20220202204910068](computer_network_hnust.assets/image-20220202204910068.png)

11，主机A将发送窗口内序号301~400的数据封装成一个TCP报文段发送出去，发送窗口内还有100字节可以发送：

![image-20220202205029404](computer_network_hnust.assets/image-20220202205029404.png)

12，主机A将发送窗口内序号401~500的数据封装成一个TCP报文段发送出去，至此序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了：

![image-20220202205137516](computer_network_hnust.assets/image-20220202205137516.png)

13，现在，发送窗口内序号201~300这100个字节数据的重传计时器超时了，主机A将他们重新封装成一个TCP报文段发送出去，暂时不能发送其他数据：

![image-20220202205340747](computer_network_hnust.assets/image-20220202205340747.png)

14，主机B收到该重传的TCP报文段后，对主机A所发送的501号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为100；这是主机B对主机A进行的第二次流量控制：

![image-20220202205530932](computer_network_hnust.assets/image-20220202205530932.png)

15，主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移除发送窗口；由于主机B在该累计确认中将自己的接收窗口调整为了100，因此主机A相应地将自己的发送窗口调整为100：

![image-20220202205745049](computer_network_hnust.assets/image-20220202205745049.png)

16，目前主机A发送窗口内的序号为501~600，也就是主机A还可以发送这100字节；主机A现在可将发送缓存中序号201~500的字节数据全部删除了，因为已经收到了主机B对他们的累计确认：

![image-20220202210112116](computer_network_hnust.assets/image-20220202210112116.png)

17，主机A将发送窗口内501~600的数据封装成一个TCP报文段发送出去，至此，序号落在发送窗口内的数据已经全部发送出去了，不能再发送新数据了：

![image-20220202210242949](computer_network_hnust.assets/image-20220202210242949.png)

18，主机B对主机A所发送的601号以前的数据进行累计确认，并在该累计确认中将窗口字段的值调整为0；这是主机B对主机A进行的第三次流量控制：

![image-20220202210611549](computer_network_hnust.assets/image-20220202210611549.png)

19，主机A收到该累计确认后，将发送窗口向前滑动，使已发送并收到确认的这些数据的序号移除发送窗口；由于主机B在该累计确认中将自己的接收窗口调整为0，因此主机A相应地将自己的发送窗口调整为0；目前主机A不能再发送一般的TCP报文段了：

![image-20220202210950295](computer_network_hnust.assets/image-20220202210950295.png)

20，主机A现在可将发送缓存中序号501~600的字节数据全部删除了，因为已经收到了主机B对他们的累计确认：

![image-20220202211112332](computer_network_hnust.assets/image-20220202211112332.png)

21，假设主机B向主机A发送了零窗口报文段后不久，主机B的接收缓存又有了一些存储空间；于是主机B向主机A发送了接收窗口等于300的报文段，但是这个报文段在传输过程中丢失了：

![image-20220202211321975](computer_network_hnust.assets/image-20220202211321975.png)

22，主机A一直等待主机B发送的非零窗口的通知，而主机B也一直等待主机A发送的数据；如果不采取措施，这种互相等待而形成的死锁局面会一直持续下去：

![image-20220202211452987](computer_network_hnust.assets/image-20220202211452987.png)

23，为了解决这个问题，TCP为每个连接舍友一个持续计时器；只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器；若持续计时器超时，就发送一个零窗口探测报文，仅携带一字节的数据；而对方在确认这个探测报文段时，给出自己现在的接收窗口值，如果接收窗口仍然是0，那么收到这个报文段的一方就会重新启动持续计时器，如果接收窗口不是0，那么死锁的局面就会被打破了。

24，在本例中，主机A收到零窗口通知时就启动一个持续计时器；当持续计时器超时，主机A立刻发送一个仅携带一字节数据的零窗口探测报文段：

![image-20220202212104669](computer_network_hnust.assets/image-20220202212104669.png)

25，假设主机B此时的接收窗口仍然是0，主机B就在确认这个零窗口探测报文段时，给出字节现在的接收窗口值为0；主机A再次收到零窗口通知，就再启动一个持续计时器：

![image-20220202212421609](computer_network_hnust.assets/image-20220202212421609.png)

26，当持续计时器超时，主机A立刻发送一个零窗口探测报文段；假设主机B此时的缓存你又有了一些存储空间，于是将自己的接收窗口调整为了300，主机B就在确认这个零窗口探测报文时，给出自己现在的接收窗口值为300；这样就打破了死锁局面：

![image-20220202212708541](computer_network_hnust.assets/image-20220202212708541.png)

- 有人可能有这样的疑问：“主机A所发送的零窗口探测报文段到达主机B时，如果主机B此时的接收窗口仍然是0，那么主机B根本无法接收该报文段，又怎么会针对该报文段该主机A发回确认呢”。实际上TCP规定，即使接收窗口为0，也必须接受”零窗口报文段，确认报文段，以及携带有紧急数据的报文段“
- 思考：“如果零窗口探测报文段丢失了怎么办？”。零窗口探测报文段也有重传计时器，当重传计时器超时后，零窗口探测报文段会被重传。



#### 小练习

![image-20220202213245974](computer_network_hnust.assets/image-20220202213245974.png)

#### 小结

![image-20220202213314071](computer_network_hnust.assets/image-20220202213314071.png)



### TCP的拥塞控制

#### 概念

![image-20220202225525188](computer_network_hnust.assets/image-20220202225525188.png)

#### 讨论拥塞控制算法的准备知识

1，种类有：

![image-20220202225550296](computer_network_hnust.assets/image-20220202225550296.png)

2，为了方便算法讨论，做如下假设：

![image-20220202231548095](computer_network_hnust.assets/image-20220202231548095.png)

3，发送方需要维护的状态变量：

![image-20220202231748045](computer_network_hnust.assets/image-20220202231748045.png)

#### 拥塞控制算法-慢开始+拥塞避免

1，首先来看“慢开始”；为了更清楚地显示出拥塞控制的过程，我们可以绘制如下“拥塞窗口随传输轮次变化的图”：

![image-20220203111844249](computer_network_hnust.assets/image-20220203111844249.png)

- 横坐标为传输伦次，传输伦次是指发送方给接收方发送数据报文段后，接收方给发送方发回相应的确认报文段，一个传输轮次所经历的时间其实就是往返时间，请注意往返时间并非是恒定的数值，使用传输轮次是为了强调“把拥塞窗口所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认”；
- 纵坐标是拥塞窗口，他会随网络拥塞程度以及所使用的拥塞控制算法动态变化

2，在TCP双方建立逻辑连接关系时，拥塞窗口的值被设置为1，我们在图上标出传输轮次0时的拥塞窗口值为1；另外还需设置慢开始门限的初始值，本例采用16，我们也将它在图中标出：

![image-20220203112155047](computer_network_hnust.assets/image-20220203112155047.png)

3，在执行慢开始算法时，发送方每收到一个对新报文段的确认时就把拥塞窗口值指数型增加(本例为乘2)(老师口误成“加一”)，然后开始下一轮的传输；当拥塞窗口值增长到慢开始门限值时，就改为执行拥塞避免算法。

4，由于发送方当前的拥塞窗口值是1，而发送窗口值等于拥塞窗口值，因此发送方当前只能发送一个TCP数据报文段；换句话说，拥塞窗口值是几，就能发送几个数据报文段；如图所示，发送方发送0号数据报文段，接收方收到后给发送方发回对0号报文段的确认报文段：

![image-20220203112954231](computer_network_hnust.assets/image-20220203112954231.png)

5，发送方收到该确认报文段后，将拥塞窗口值加一增大到2，我们在图中标出该值，这意味着发送方现在可以发送1~2号共两个数据报文段；接受方收到后，给发送方发回对1~2号报文段的确认报文段：

![image-20220203113134914](computer_network_hnust.assets/image-20220203113134914.png)

6，发送方收到后，将拥塞窗口值加2增大到4，在图中标出该值；发送方现在可以发送3~6号共四个数据报文段；接受方收到后，给发送方发回对3~6号报文段的确认报文段：

![image-20220203113342630](computer_network_hnust.assets/image-20220203113342630.png)

7，发送方收到后，将拥塞窗口值加4增加到8，我们在图中标出该值；发送方现在可以发送7~14号共8个数据报文段；接受方收到后，给发送方发回对7~14号报文段的确认报文段：

![image-20220203113729923](computer_network_hnust.assets/image-20220203113729923.png)

8，发送方收到后，将拥塞窗口值加8增加到16，我们在图中标出该值；发送方当前的拥塞窗口值已经增大到了慢开始门限值，之后我们要改用拥塞避免算法，也就是每个传输轮次结束后，拥塞窗口值只能线性加一，而不像慢开始算法那样，每个传输轮次结束后按指数规律增大；发送方现在可以发送15~30号共16个数据报文段，接收方收到后，给发送方发回对15~30号报文段的确认报文段：

![image-20220203114513154](computer_network_hnust.assets/image-20220203114513154.png)

9，发送方收到后将拥塞窗口值加一增大到17，我们在图中表出该值；发送方现在可以发送31~47号共17个数据报文段，接收方收到后，给发送方发回对31~47号报文段的确认报文段：

![image-20220203114757632](computer_network_hnust.assets/image-20220203114757632.png)

10，发送方收到后，将拥塞窗口值加1增加到18；随着传输轮次的增加，拥塞窗口值每轮次都线性加一，例如当前拥塞窗口值增加到了24；发送方现在可以发送171~194号共24个数据报文段；假设这24个数据报文段在传输过程中丢失了几个：

![image-20220203115231905](computer_network_hnust.assets/image-20220203115231905.png)

11，这必然会造成发送方对这些丢失报文段的超时重传，发送方以此判断网络很可能出现了拥塞，需要进行图中所示的工作：

![image-20220203115450325](computer_network_hnust.assets/image-20220203115450325.png)

12，慢开始算法不断执行：

![image-20220203115803131](computer_network_hnust.assets/image-20220203115803131.png)

13，慢开始算法执行到拥塞窗口值增大到新的慢开始门限值时，就停止使用慢开始算法；转而执行拥塞避免算法，如图所示：

![image-20220203115929214](computer_network_hnust.assets/image-20220203115929214.png)

14，通过本例可以看出：

![image-20220203120651702](computer_network_hnust.assets/image-20220203120651702.png)

1. TCP发送方一开始使用慢开始算法，让拥塞窗口值从1开始按指数规律增大；
2. 当拥塞窗口值增大到慢开始门限值时，停止使用慢开始算法，转而执行拥塞避免算法，拥塞窗口值按线性加一的规律增大；
3. 当发生超时重传时，就判断网络很可能出现了拥塞，采取如图的相应的措施
4. 拥塞窗口值又从1开始按指数规律增大
5. 当增大到了新的慢开始门限值时，停止使用慢开始算法转而使用拥塞避免算法，让拥塞窗口值按线性加一的规律增大

15，需要注意的是：

- “慢开始”是指一开始向网络注入的报文段少，并不是指拥塞窗口cwnd增长速度慢;
- “拥塞避免”并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞；



#### 拥塞控制算法-快重传+快恢复

1，引入快重传：

![image-20220203121351307](computer_network_hnust.assets/image-20220203121351307.png)

- 网络正常而个别报文丢失时，快重传可以避免发送方的超时计时器超时，从而避免让发送方误以为网络拥塞而执行慢开始算法。

2，我们来举例快重传算法；发送方发送1号数据报文段，接收方收到后给发送方发回对1号报文段得确认；在该确认报文段到达发送方之前，发送方还可以将发送窗口内的2号数据报文段发送出去：

![image-20220203122113525](computer_network_hnust.assets/image-20220203122113525.png)

3，接收方收到后给发送方发回对2号报文段的确认；在该确认报文段到达发送方之前，发送方还可以将发送窗口内的3号数据报文段发送出去，但该报文段丢失了，接收方自然不会给发送方发回针对该报文段的确认：

![image-20220203122427520](computer_network_hnust.assets/image-20220203122427520.png)

4，发送放还可以将发送窗口内的4号报文段发送出去，接收方收到后发现这不是按序到达的报文段，因此给发送方发回针对2号报文段的重复确认，表明：“我现在希望收到的是3号报文段，但是我没有收到3号报文段，而是收到了未按序到达的报文段”：

![image-20220203122648479](computer_network_hnust.assets/image-20220203122648479.png)

5，发送方继续发送5号6号数据报文段，并再收到两个针对2号报文段的重复确认；至此发送方会收到三个连续的对2号报文段的重复确认，就立即重传3号报文段：

![image-20220203122905277](computer_network_hnust.assets/image-20220203122905277.png)

6，接收方收到重传的3号报文段后，给发送方发回针对6号报文段的确认，表明序号到6为止的报文段都正确接收了，这样就不会造成对3号报文段的超时重传，而是提早进行了重传：

![image-20220203123213996](computer_network_hnust.assets/image-20220203123213996.png)

- 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1)。使用快重传可以使整个网络的吞吐量提高约20%。

7，再来看快恢复算法，基本概念如图中框：

![image-20220203123405866](computer_network_hnust.assets/image-20220203123405866.png)



#### TCP拥塞窗口值在拥塞控制时的变化情况举例

本举例包含了TCP拥塞控制的**四种**算法：

![image-20220203123843672](computer_network_hnust.assets/image-20220203123843672.png)

- 收到三个重复确认时，就进行“快重传+快恢复”。
- 本图中“字或背景的颜色”对应了不同的算法！



#### 小练习

![image-20220203124008587](computer_network_hnust.assets/image-20220203124008587.png)

- 超时用“慢开始”，三次确认使用“快重传”后未超时用“快恢复”；快重传可以避免超时的发生
- 本题目说了是超时，超时就代表拥塞，拥塞就得使用慢开始算法。快重传是指还未超时时连续收到三个重复确认。

#### 小结

![image-20220203124402705](computer_network_hnust.assets/image-20220203124402705.png)

### TCP超时重传时间的选择

#### 简单引入

![image-20220203151812200](computer_network_hnust.assets/image-20220203151812200.png)

- 超时重传时间RTO的值应该设置为略大于报文段往返时间RTT的值
  - RTO太小会造成很多不必要的超时重传。
  - RTO太大会使网络的空闲时间增大，降低了传输效率。

- 看起来很简单；但是TCP下层是复杂的互联网环境，主机A所发送的报文段，可能只经过一个高速率的局域网，也有可能经过多个低速率的网络，并且每个IP数据报的转发路由还可能不同。所以一个RTO应用于所有的传输是不合理的。



#### 加权平均RTTs的计算与使用

![image-20220203152429819](computer_network_hnust.assets/image-20220203152429819.png)



#### RFC6298建议使用的超时重传时间RTO计算公式

![image-20220203153034748](computer_network_hnust.assets/image-20220203153034748.png)

- 我们可以发现，不管是RTTs还是RTTd都是基于测量到的RTT样本进行计算的；如果所测量的样本不正确，那么所计算出的RTTs和RTTd自然就不正确，进而所计算出的超时重传时间RTO也就不正确。



#### 往返时间RTT的测量比较复杂

1，重传报文段时出现的问题：

![image-20220203153338507](computer_network_hnust.assets/image-20220203153338507.png)

- 通过这两个例子可以看出，当发送方出现超时重传后，收到确认报文段时，是无法判断出该确认到底是对原报文段的确认，还是对重传报文段的确认；也就是无法准确测量出RTT，进而无法正确计算超时重传时间RTO。

2，Karn算法：

![image-20220203153453185](computer_network_hnust.assets/image-20220203153453185.png)



#### RTO计算实例

1，求RTTs：

![image-20220203153854092](computer_network_hnust.assets/image-20220203153854092.png)

2，求RTTd：

![image-20220203153956868](computer_network_hnust.assets/image-20220203153956868.png)

3，非超时重传时，求RTO：

![image-20220203154125989](computer_network_hnust.assets/image-20220203154125989.png)

4，超时重传时，求RTO：

![image-20220203154354475](computer_network_hnust.assets/image-20220203154354475.png)



#### 小结

![image-20220203154425901](computer_network_hnust.assets/image-20220203154425901.png)



### TCP可靠传输的实现

TCP基于**以字节为单位的滑动窗口**来实现可靠传输

#### 实例

1，两个主机已经建立了一个TCP连接：

![image-20220203170729533](computer_network_hnust.assets/image-20220203170729533.png)

2，为了简单起见，我们假定数据传输只在一个方向进行；换句话说，发送方给接收方发送TCP数据报文段，接收方给发送方发送相应的TCP确认报文段；这样的好处是使讨论仅限于两个窗口，也就是发送方的发送窗口和接收方的接收窗口：

![image-20220203170810882](computer_network_hnust.assets/image-20220203170810882.png)

3，TCP的滑动窗口是以字节为单位的，如图所示，这是发送方待发送字节的序号：

![image-20220203171117436](computer_network_hnust.assets/image-20220203171117436.png)

4，假设发送方收到了一个来自接收方的确认报文段；在报文段首部中的窗口字段的值为20，也就是接收方表明自己的接收窗口的尺寸为20字节；确认好字段的值为31，这表明接收方希望收到下一个数据的序号是31，而序号30为止的数据已经全部正确接收了：

![image-20220203171446014](computer_network_hnust.assets/image-20220203171446014.png)

5，因此发送方根据这两个字段的值构造出自己的发送窗口，如图所示；为了简单起见，我们假设网络不存在拥塞问题，也就是发送方在构造自己的发送窗口是，仅考虑接收方的接收窗口，而不考虑拥塞窗口；由于本例中接收方告诉发送方自己的接收窗口尺寸为20，因此发送方将自己的发送窗口尺寸也设置为20：

![image-20220203171914887](computer_network_hnust.assets/image-20220203171914887.png)

- 发送方在没有收到接收方确认的情况下，可以把发送窗口内的数据依次全部发送出去；
- 凡是已经发送了的数据，在未收到确认之前，都必须暂时保留，以便在超时重传时使用

6，发送窗口的后沿和前沿如图所示：

![image-20220203172301820](computer_network_hnust.assets/image-20220203172301820.png)

- 后沿的后边的字节可以删除
- 前沿的前边的字节不允许发送

7，发送窗口后沿和前沿的移动情况如图：

![image-20220203172846611](computer_network_hnust.assets/image-20220203172846611.png)

- 发送窗口的后沿不可能向后移动，因为不能撤销掉已收到的确认
- TCP标准强烈不推荐让发送窗口的前沿后缩，因为很可能发送方在收到这个通知前，就已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，显然就会产生错误。

8，现在假定发送方将发送窗口内序号31~41的数据封装在几个不同的报文段中发送出去，此时发送窗口的位置并没有改变；送窗口内序号31~41的数据已经发送但未收到确认，而序号42~50的数据是允许发送但还未发送的：

![image-20220203173355177](computer_network_hnust.assets/image-20220203173355177.png)

9，思考“如何描述发送窗口的状态？”。可以使用三个指针P1，P2，P3分别指向相应的字节序号，如图所示：

![image-20220203173611934](computer_network_hnust.assets/image-20220203173611934.png)

10，我们再来看看接收方的接收窗口，他的尺寸为20；在接收窗口外面到30号为止的数据是无需再保留的数据，可将他们从接收缓存中删除；接收窗口内31~50号数据是允许接收的数据；接收窗口外51号及其后续数据，目前不允许接收：

![image-20220203174035905](computer_network_hnust.assets/image-20220203174035905.png)

11，假设发送方之前发送的封装有32和33号数据的报文段到达了接收方，由于数据序号落在接收窗口内，所以接收方接收他们，并将他们存入接收缓存；但是他们是未按序到达的数据，因为31号数据还没到达，31号数据可能是丢了，也有可能是滞留在网络中的某处；请注意“接收方只能对按序收到的数据中的最高序号给出确认”，因此接收方发出的确认报文段中的确认序号仍然是31，也就是希望收到31号数据；窗口字段的值仍是20表明接收方没有改变自己接收窗口的大小：

![image-20220203174458436](computer_network_hnust.assets/image-20220203174458436.png)

12，发送方收到该确认报文段后，发现这是一个针对31号数据的重复确认，就知道接收方收到了未按序到达的数据；由于这是针对31号数据的第一个重复确认，因此这并不会引起发送方针对该数据的快重传；另外接收方通知的窗口尺寸仍是20，因此发送方仍保持自己的发送窗口尺寸为20。

13，现在假设封装有31号数据的报文段到达了接收方：

![image-20220203174948408](computer_network_hnust.assets/image-20220203174948408.png)

14，接收方接受该报文段，将其封装的31号数据存入接收缓存：

![image-20220203175140399](computer_network_hnust.assets/image-20220203175140399.png)

15，接收方现在可将接收到的31~33号数据交付给应用进程，然后将接收窗口向前移动3个序号，并给发送方发送确认报文段；该确认报文段中窗口字段的值仍为20，表明接收方没有改变自己接收窗口的大小；确认号字段的值为34，这表明接收方已经收到了序号33为止的全部数据：

![image-20220203175400754](computer_network_hnust.assets/image-20220203175400754.png)

16，现在，假设又有几个数据报文段到达了接收方，他们封装有“37,38，和40号”数据：

![image-20220203175956346](computer_network_hnust.assets/image-20220203175956346.png)

17，这些数据的序号虽然落在接收窗口内，但他们都是未按序到达的数据，只能先暂存在接收缓存中：

![image-20220203180040300](computer_network_hnust.assets/image-20220203180040300.png)



18，假设接收方先前发送的确认报文段到达了发送方：

![image-20220203180435098](computer_network_hnust.assets/image-20220203180435098.png)

19，发送方接收后，将发送窗口向前滑动3个序号，发送窗口的尺寸保持不变，这样就有新序号51~53落入发送窗口中，而序号31~33移出了发送窗口：

![image-20220203180354015](computer_network_hnust.assets/image-20220203180354015.png)

20，现在可将31~33号数据从发送缓存中删除了，因为已经收到了接收方针对他们的确认：

![image-20220203180548833](computer_network_hnust.assets/image-20220203180548833.png)

21，发送方继续将发送窗口内序号42~53的数据封装在几个不同的报文段中发送出去，现在发送窗口内的序号已经用完了；发送方在未收到接收方发来确认的情况下，不能再发送新的数据：

![image-20220203180917588](computer_network_hnust.assets/image-20220203180917588.png)

22，序号落在发送窗口内的已发送数据，如果迟迟收不到接收方的确认，则会产生超时重传：

![image-20220203181029071](computer_network_hnust.assets/image-20220203181029071.png)



23，接下来，我们对TCP可靠传输的实现做几点补充说明：

![image-20220203200743636](computer_network_hnust.assets/image-20220203200743636.png)

- 网友：“捎带确认就是在接受方要给发送方发数据时将ACK字段设为1就有确认的功能了”



#### 小练习

1,

![image-20220203200830573](computer_network_hnust.assets/image-20220203200830573.png)

2，

![image-20220203200908619](computer_network_hnust.assets/image-20220203200908619.png)



#### 小结

![image-20220203200948399](computer_network_hnust.assets/image-20220203200948399.png)



### TCP的运输连接管理-TCP的连接建立

#### TCP运输连接概述

![image-20220203201135973](computer_network_hnust.assets/image-20220203201135973.png)

- 本节课介绍“建立TCP连接”



#### TCP连接建立要解决的问题

![image-20220203201335474](computer_network_hnust.assets/image-20220203201335474.png)



#### 三报文握手实例

1，这是两台要基于TCP进行通信的主机，其中一台主机中的某个应用进程主动发起TCP连接建立，称为TCP客户；另一台主机中被动等待TCP连接建立的应用进程，称为TCP服务器；我们可以将TCP建立连接的过程比喻为“握手”，“握手”需要在TCP客户和服务器之间交换三个TCP报文段：

![image-20220203201811140](computer_network_hnust.assets/image-20220203201811140.png)

2，最初，两端的TCP进程都出于关闭状态

![image-20220203201835665](computer_network_hnust.assets/image-20220203201835665.png)

3，一开始，TCP服务器进程首先创建**传输控制块**，用来**存储TCP连接中的一些重要信息**；之后就准备接受TCP客户进程的连接请求，此时TCP服务器进程就进入监听状态，等待TCP客户的连接请求：

![image-20220203202118792](computer_network_hnust.assets/image-20220203202118792.png)

4，TCP服务器进程是被动等待来自TCP客户端进程的连接请求，而不是主动发起，因此称为“被动打开连接”：

![image-20220203202438620](computer_network_hnust.assets/image-20220203202438620.png)

5，TCP客户进程也是首先创建传输控制块：

![image-20220203202608891](computer_network_hnust.assets/image-20220203202608891.png)

6，然后在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入“同步已发送状态”：

![image-20220203202723968](computer_network_hnust.assets/image-20220203202723968.png)

- TCP连接请求报文段首部中的同步位**SYN**被设置为1，表明这是一个TCP连接请求报文段
- 序号字段**seq**被设置了一个初始值x，作为TCP客户进程所选择的初始序号
- 请注意，TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号

7，由于TCP连接建立是由TCP客户主动发起的，因此称为”主动打开连接“：

![image-20220203203139243](computer_network_hnust.assets/image-20220203203139243.png)

8，TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态：

![image-20220203203739888](computer_network_hnust.assets/image-20220203203739888.png)

- 该报文段首部中的同步位**SYN**和确认位**ACK**都设置为1，表明这是一个TCP连接请求确认报文段；
- 序号字段**seq**被设置了一个初始值y，作为TCP服务进程所选择的初始序号；
- 确认号字段**ack**的值被设置成了x+1，这是对TCP客户进程所选择的初始序号的确认；
- 请注意，这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号；

9，TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入“连接已建立状态”：

![image-20220203204537474](computer_network_hnust.assets/image-20220203204537474.png)

- 该报文段首部中的确认位**ACK**被设置为1，表明这是一个普通的TCP确认报文段；
- 序号字段**seq**被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x并且不携带数据，因此第二个报文段的序号为x+1；
- 请注意，**TCP规定普通的TCP确认报文段可以携带数据**；但如果不携带数据，则不消耗序号，在这种情况下，所发送的下一个数据报文段的序号仍是x+1；

- 确认号字段**ack**被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认；

10，TCP服务器进程收到该确认报文段后也进入连接已建立状态；现在TCP双方都进入了连接已建立状态，他们可以基于已建立好的TCP连接进行可靠的数据传输了：

![image-20220203204759405](computer_network_hnust.assets/image-20220203204759405.png)

11，思考“为什么TCP客户进程最后还要发送一个普通的TCP确认报文段呢？这是否多余？换句话说，能否使用两报文建立连接呢？”。答案是“并不多余，不能简化为两报文握手”，

#### 第三次握手的必要性

1，我们来举例说明，考虑这样一种情况，TCP客户进程发出一个TCP连接请求报文段，但该报文段在某些网络结点长时间滞留了，这必然会造成该报文段的超时重传；假设重传的报文段被TCP服务器进程正常接收：

![image-20220203205901722](computer_network_hnust.assets/image-20220203205901722.png)

2，TCP服务器进程给TCP客户端进程发送一个TCP连接请求确认报文段，并进入”连接已建立状态“

![image-20220203210034648](computer_network_hnust.assets/image-20220203210034648.png)

- 请注意，由于我们改为“两报文握手”，因此TCP服务器进程发送完TCP连接请求确认报文段后，进入的是”连接已建立状态“；而不像“三报文握手”那样进入“同步已接收状态”，并等待TCP客户进程发来针对TCP连接请求确认报文段的普通确认报文段。

3，TCP客户进程收到TCP连接请求确认报文段后，进入TCP连接已建立状态，但不会给TCP服务器进程发送针对该报文段的普通确认报文段：

![image-20220203210502326](computer_network_hnust.assets/image-20220203210502326.png)

4，现在TCP双方都处于“连接已建立状态”，他们可以相互传输数据；之后可以通过“四报文挥手”来释放连接；TCP双方都进入了关闭状态：

![image-20220203210817786](computer_network_hnust.assets/image-20220203210817786.png)

5，一段时间后，之前滞留在网络中的失效的请求报文段到达了TCP服务器进程：

![image-20220203211002366](computer_network_hnust.assets/image-20220203211002366.png)

6，TCP服务进程会误认为这是TCP客户进程又发起了一个新的TCP连接请求，于是给TCP客户进程发送TCP连接请求确认报文段，并进入”连接已建立状态“：

![image-20220203211121274](computer_network_hnust.assets/image-20220203211121274.png)

7，该报文段到达TCP客户进程，由于TCP客户进程并没有发起新的TCP连接请求，并且处于关闭状态，因此不会理会该报文段；但TCP服务器进程已进入”连接已建立状态“，它认为新的TCP连接已经建立好了，并一直等待TCP客户进程发来数据，这将白白浪费TCP服务器进程所在主机的很多资源：

![image-20220203211415783](computer_network_hnust.assets/image-20220203211415783.png)

8，综上所述，**采用”3报文握手“而不是“2报文握手”来建立TCP连接，是为了防止已失效的连接请求报文段突然又传送到了TCP服务器进程，因而导致错误**：

![image-20220203211650141](computer_network_hnust.assets/image-20220203211650141.png)

- 网友：“简单来讲就是为了告知服务器，客户机还有发送数据的能力”



#### 小练习

![image-20220203212010881](computer_network_hnust.assets/image-20220203212010881.png)



#### 小结

![image-20220203212038893](computer_network_hnust.assets/image-20220203212038893.png)



### TCP的运输连接管理-TCP的连接释放

TCP通过4报文挥手来释放连接。



#### 实例

1，我们来举例说明，数据传输结束后，TCP双方都可以释放连接，现在TCP客户进程和TCP服务器进程都出于连接已建立状态；假设使用TCP客户进程的应用进程通知其主动关闭TCP连接，TCP客户进程会发送TCP连接释放报文段，并进入”终止等待1“状态：

![image-20220203225954510](computer_network_hnust.assets/image-20220203225954510.png)

- 该报文首部中的终止位**FIN**和确认位**ACK**的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；
- 序号**seq**字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1；
- 请注意，TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号；
- 确认号**ack**字段的值设置为v，它等于TCP客户进程之前已收到的数据的最后一个字节的序号加1；

2，TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入“关闭等待”状态：

![image-20220203231228145](computer_network_hnust.assets/image-20220203231228145.png)

- 该报文段首部中确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；
- 序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配；
- 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认；

3，TCP服务器进程这时应通知高层应用进程：“TCP客户进程要断开与自己的TCP连接”：

![image-20220203231834581](computer_network_hnust.assets/image-20220203231834581.png)

4，此时从TCP客户进程到TCP服务器进程这个方向的连接就释放了，这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了；那TCP服务器进程如果还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户端进程这个方向的连接并未关闭，这个状态可能会持续一段时间：

![image-20220203232028793](computer_network_hnust.assets/image-20220203232028793.png)

5，TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段：

![image-20220203232708918](computer_network_hnust.assets/image-20220203232708918.png)

6，若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接；由于TCP连接释放是由TCP客户端进程主动发起的，因此TCP服务器进程对TCP连接的释放称为”被动关闭连接“：

![image-20220203232942993](computer_network_hnust.assets/image-20220203232942993.png)

7，TCP服务器进程发送TCP连接释放报文段并进入最后确认状态：

![image-20220203234002085](computer_network_hnust.assets/image-20220203234002085.png)

- 该报文段首部中的终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认；
- 现在假定序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送了一些数据；
- 确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认

8，TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态：

![image-20220203234458186](computer_network_hnust.assets/image-20220203234458186.png)

- 该报文段首部中的确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段；
- 序号seq字段的值设置为u+1，这是因为TCP客户端之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号；
- 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认

9，TCP服务器进程收到该报文段后就进入了关闭状态；而TCP客户进程还要进过2MSL后才能进入关闭状态：

![image-20220203235007134](computer_network_hnust.assets/image-20220203235007134.png)

- MSL(Maximum Segment Lifetime)意思是最长报文段寿命，RFC793建议为2分钟。

- 也就是说TCP客户进程进入时间等待状态后，还要经过4分钟才能进入关闭状态，这完全是从工程上考虑的；对于现在的网络，MSL取为2分钟可能太长了，因此TCP允许不同的实现可根据具体情况使用更小的MSL值。

10，那么TCP客户进程在发送完最后一个确认报文段后，为什么不直接进入关闭状态？而是要进入时间等待状态，2MSL后才进入关闭状态？这是否必要呢？

![image-20220203235216133](computer_network_hnust.assets/image-20220203235216133.png)



#### 时间等待状态的必要性

1，来看这种情况，TCP服务器进程发送TCP连接释放报文段后进入最后确认状态；TCP客户进程收到该报文段后，发送普通的TCP确认报文段并进入关闭状态而不是时间等待状态：

![image-20220203235541307](computer_network_hnust.assets/image-20220203235541307.png)

2，然而该TCP确认报文段丢失了，这必然会造成TCP服务器进程对之前所发送的TCP连接释放报文段的超时重传，并仍处于最后确认状态：

![image-20220204000542040](computer_network_hnust.assets/image-20220204000542040.png)

3，重传的TCP连接释放报文段到达TCP客户进程，由于TCP客户进程属于关闭状态，因此不理睬该报文；这必然会造成TCP服务器进程反复重传TCP连接释放报文段，并一直处于最后确认状态而无法进入关闭状态：

![image-20220204001245625](computer_network_hnust.assets/image-20220204001245625.png)

4，因此，“时间等待状态”的作用有：

- 时间等待状态，以及处于该状态2MSL时长可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态；
- 另外，TCP客户进程在发送完最后一个TCP确认报文段后，再经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段。以上就是TCP通过“四报文挥手”释放连接的过程。



#### TCP中保活计时器的作用

![image-20220204001501345](computer_network_hnust.assets/image-20220204001501345.png)



#### 小结

![image-20220204001540764](computer_network_hnust.assets/image-20220204001540764.png)



### TCP报文段的首部格式

#### 概述

1，

![image-20220204121917008](computer_network_hnust.assets/image-20220204121917008.png)



2，TCP数据报的首部格式与IP数据报的首部格式类似，都是由20字节的固定首部和最大40字节的扩展首部构成：

![image-20220204122119545](computer_network_hnust.assets/image-20220204122119545.png)

#### 源端口和目的端口

1，源端口和目的端口用处：

![image-20220204122304504](computer_network_hnust.assets/image-20220204122304504.png)

2，举例说明源端口和目的端口的作用，假设主机中的浏览器进程要访问WEB服务器中的WEB服务器进程，为了简单起见，我们仅从运输层端口号这个角度来举例说明，而不考虑其他细节，例如“ARP，域名解析，TCP连接建立”等。

3，当在浏览器地址栏中输入了WEB服务器的域名后，浏览器进程会构建一个封装有HTTP请求报文的TCP报文段；该报文段首部中的源端口字段会填写一个短暂端口号，例如49152，用来标识发送该报文段的浏览器进程；目的端口字段会填写熟知端口号80，因为使用HTTP协议的WEB服务器进程默认监听该端口：

![image-20220204123008452](computer_network_hnust.assets/image-20220204123008452.png)

4，WEB服务器收到该TCP报文段后，从中解封出HTTP请求报文；并根据TCP报文段首部中目的端口字段的值80，将HTTP请求报文上交给WEB服务器进程：

![image-20220204145914348](computer_network_hnust.assets/image-20220204145914348.png)

5，WEB服务器进程根据HTTP请求报文的内容进行相应处理，并构建一个HTTP相应报文；HTTP响应报文需要封装成TCP报文段进行发送：

![image-20220204150317911](computer_network_hnust.assets/image-20220204150317911.png)

- 该报文段首部中的源端口字段会填写熟知端口号80，用来表示发送该TCP报文段的WEB服务器进程；
- 而目的端口字段会填写49152，这是主机中需要接收该TCP报文段的浏览器进程所对应的端口号

6，主机收到该TCP报文段后，从中解封出HTTP响应报文，并根据TCP报文段首部中目的端口字段的值49152，将HTTP响应报文上交给浏览器进程：

![image-20220204150523912](computer_network_hnust.assets/image-20220204150523912.png)

7，浏览器进程对HTTP响应报文的内容进行解析并显示：

![image-20220204150627788](computer_network_hnust.assets/image-20220204150627788.png)



#### 序号+确认号+确认标志位ACK

这三个字段与TCP实现可靠传输相关。

1，序号字段讲解

![image-20220204150907050](computer_network_hnust.assets/image-20220204150907050.png)

2，确认号字段讲解

![image-20220204151004644](computer_network_hnust.assets/image-20220204151004644.png)

3，确认标志位ACK讲解

![image-20220204151058020](computer_network_hnust.assets/image-20220204151058020.png)

4，三个字段的作用实例

4.1，TCP客户进程发送一个TCP报文段：

![image-20220204151532228](computer_network_hnust.assets/image-20220204151532228.png)

- 该报文段首部中序号字段的取值为201，这表示该TCP报文段数据载荷的第一个字节的序号为201；
- 假设数据长度为100字节；
- 首部中确认号字段的取值为800，这表示TCP客户进程收到了TCP服务器进程发来的序号到799为止的全部数据，现在期望收到序号从800开始的数据；
- 为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1；

4.2，TCP服务器进程收到该报文段后，也给TCP客户进程发送TCP报文段：

![image-20220204152404957](computer_network_hnust.assets/image-20220204152404957.png)

- 该报文段首部中序号字段的取值为800，这表示该TCP报文段数据载荷的第一个字节的序号为800，这正好与TCP客户进程的确认相匹配；
- 假设数据载荷的长度为200字节；
- 首部中确认号字段的取值为301，这表示TCP服务器进程收到了TCP客户进程发来的序号到300为止的全部数据，现在希望收到序号从301开始的数据；
- 为了使确认号字段有效，首部中的确认标志位ACK的值必须设置为1；



#### 数据偏移字段

1，概念讲解

![image-20220204152647361](computer_network_hnust.assets/image-20220204152647361.png)

- 0101十进制是5，单位为4字节，所以首部固定长度是20字节



#### 保留字段

![image-20220204152954451](computer_network_hnust.assets/image-20220204152954451.png)

#### 窗口字段

![image-20220204153117498](computer_network_hnust.assets/image-20220204153117498.png)

- 需要注意：发送窗口的大小还取决于拥塞窗口的大小，也就是应该从接收窗口和拥塞窗口中取小者。

#### 校验和字段

![image-20220204153405117](computer_network_hnust.assets/image-20220204153405117.png)

- 与UDP类似，在计算校验和时，要在TCP报文段的前面加上12字节的伪首部；
- 具体的校验算法就不赘述了，因为它仅仅是一种检错算法，与TCP的其他重要功能相比，检错算法并不是重点；



#### 同步标志位SYN

![image-20220204153821766](computer_network_hnust.assets/image-20220204153821766.png)

- TCP客户进程发送的TCP连接请求报文段，首部中的同步标志位SYN被置1，表明这是一个TCP连接请求报文段；
- TCP服务器进程发送的TCP连接请求确认报文段，首部中的同步标志位SYN被置1，确认位ACK也被置1，表明这是一个TCP连接请求确认报文段；



#### 终止标志位FIN

![image-20220204154027490](computer_network_hnust.assets/image-20220204154027490.png)

- 不管是TCP客户进程还是TCP服务器进程，他们所发送的TCP连接释放报文段首部中的终止标志位FIN都被置1，表明这是TCP连接释放报文段

#### 复位标志位RST

![image-20220204154114649](computer_network_hnust.assets/image-20220204154114649.png)

#### 推送标志位PSH

![image-20220204154157805](computer_network_hnust.assets/image-20220204154157805.png)

#### 紧急标志位URG+紧急指针字段

紧急标志位URG+紧急指针字段用来实现紧急操作。

![image-20220204154344838](computer_network_hnust.assets/image-20220204154344838.png)

- 接收方收到紧急标志为1的报文段，会按照紧急指针字段的值从报文段数据载荷部分取出紧急数据，并直接上交应用进程，而不必在接收缓存中排队。



#### 选项部分

![image-20220204154706144](computer_network_hnust.assets/image-20220204154706144.png)

- TCP报文段首部除了20字节的固定部分，还要最大40字节的选项部分；
- 增加选项可以增加TCP的功能；
- 目前有的选项如图所示。

#### 填充字段

![image-20220204154752250](computer_network_hnust.assets/image-20220204154752250.png)



#### 小结

![image-20220204154816639](computer_network_hnust.assets/image-20220204154816639.png)



## 应用层

### 应用层概述

#### 概述

1，之前学的各层：

![image-20220204161426635](computer_network_hnust.assets/image-20220204161426635.png)



2，简述应用层发展，和本章讲解方式：

![image-20220204161518183](computer_network_hnust.assets/image-20220204161518183.png)

3，浏览器输入域名后，可以访问该网站的内容

![image-20220204161734528](computer_network_hnust.assets/image-20220204161734528.png)

![image-20220204162011403](computer_network_hnust.assets/image-20220204162011403.png)

- 用户在浏览器输入的是“见名知意”的域名，而TCP/IP体系的网际层使用IP地址来标识目的主机；从域名到IP地址的转换工作由属于应用层范畴的域名系统DNS在后台帮用户自动完成，方便用户的使用。

4，常见网络应用：

![image-20220204162100837](computer_network_hnust.assets/image-20220204162100837.png)

#### 小结

![image-20220204162213443](computer_network_hnust.assets/image-20220204162213443.png)



### 客户/服务器方式(C/S)和对等方式(P2P)

#### 概述

![image-20220204200055142](computer_network_hnust.assets/image-20220204200055142.png)

#### 客户服务器方式

1，

![image-20220204200332982](computer_network_hnust.assets/image-20220204200332982.png)

2，

![image-20220204200352915](computer_network_hnust.assets/image-20220204200352915.png)

#### 对等方式

1，

![image-20220204200832052](computer_network_hnust.assets/image-20220204200832052.png)

- 我们可以想像成E的P2P进程正在从F下载文件，于此同时还为D的P2P进程提供下载服务

2，

![image-20220204200906161](computer_network_hnust.assets/image-20220204200906161.png)

#### 小结

![image-20220204201002841](computer_network_hnust.assets/image-20220204201002841.png)



### 动态主机配置协议DHCP

#### DHCP的作用

![image-20220204201217644](computer_network_hnust.assets/image-20220204201217644.png)

- DHCP服务器为局域网中的各主机自动配置网络信息。



#### DHCP工作过程实例

1，因为最后的图看的比较清晰，一步步的步骤就不写了(虽然讲的很细很好)，以后需要的话在返回来写。

2，总结图：

![image-20220204204508661](computer_network_hnust.assets/image-20220204204508661.png)

- 网友问：“这里为什么不使用mac地址辨别 而要使用事务ID？”。网友答：“请求一个IP 需要发送多个DHCP DISCOVER 收到多个DHCP OFFER 假如用MAC作为识别 则无法分辨具体是哪一个DHCP OFFER是自己真的需要的。“
- 需要注意的是，DHCP服务器在给DHCP客户挑选IP地址时，使用ARP来确保所挑选的IP地址未被网络中其他主机占用；DHCP客户在使用所租用的IP地址之前，也会使用ARP来检测该IP地址是否已经被网络中其他主机占用。



#### DHCP中继代理

1，黄色背景网络的各主机，不能通过DHCP来自动获取到网络配置信息

![image-20220204205202561](computer_network_hnust.assets/image-20220204205202561.png)

2，因为该网络中的主机广播发送DHCP发现报文，但该广播报文不会被路由器转发，而是丢弃：

![image-20220204205255617](computer_network_hnust.assets/image-20220204205255617.png)

- 路由器隔离广播域！

3，解决方法是给该路由器配置DHCP服务器的IP地址，并使之成为DHCP中继代理；这样黄色背景网络的各主机就可以通过DHCP来自动获取到网络配置信息了：

![image-20220204205445618](computer_network_hnust.assets/image-20220204205445618.png)

4，当该路由器收到广播的DHCP发现报文后，会将其单播转发给DHCP服务器：

![image-20220204205645019](computer_network_hnust.assets/image-20220204205645019.png)

5，DHCP客户和DHCP服务器通过该路由器的后续交互过程我们就不赘述了。

6，使用DHCP中继代理的主要原因是：

- 我们并不愿意在每一个网络上都设置一个DHCP服务器，因为这样会使DHCP服务器的数量太多



#### 小结

![image-20220204205817078](computer_network_hnust.assets/image-20220204205817078.png)



### 域名系统DNS

#### 域名系统的作用

1，如图，因特网中的某台主机要访问某台WEB服务器：

![image-20220204233858667](computer_network_hnust.assets/image-20220204233858667.png)

2，我们只需在用户主机中运行某个浏览器软件，在其地址栏中输入要访问的WEB服务器的域名，并按下回车键，即可访问到WEB服务器所提供的内容：

![image-20220204234038549](computer_network_hnust.assets/image-20220204234038549.png)

- 这是大家最常用的一种网络应用

3，接下来，我们在用户主机中使用ping命令，来测试用户主机与WEB服务器的连通性；可以看到，我们ping的是WEB服务器的域名，但ping命令实际上ping的是WEB服务器的IP地址，这与我们之前课程中所介绍的“TCP/IP体系采用IP地址进行寻址”的知识是一致的：

![image-20220204234459640](computer_network_hnust.assets/image-20220204234459640.png)

- 也就是说，及时不使用域名也可以通过IP地址来寻址目的主机；但域名与IP地址相比，更便于记忆；因此对于大多数网络应用，我们一般使用域名来访问目的主机，而不是直接使用IP地址来访问。

4，对于本例，简单来说，当我们在浏览器地址栏中输入某个WEB服务器的域名时，用户主机会首先在自己的DNS高速缓存中查找该域名所对应的IP地址；如果没有找到，则会向网络中的某台DNS服务器查询：

![image-20220204234944419](computer_network_hnust.assets/image-20220204234944419.png)

5，DNS服务器中有域名和IP地址映射关系的数据库；当DNS服务器收到DNS查询报文后，在其数据库中进行查询，之后将查询结果发送给用户主机：

![image-20220204235150533](computer_network_hnust.assets/image-20220204235150533.png)

6，现在主机中的浏览器可以通过WEB服务器的IP地址对其进行访问了：
![image-20220204235250584](computer_network_hnust.assets/image-20220204235250584.png)



#### 因特网使用多台DNS服务器的必要性

![image-20220204235449767](computer_network_hnust.assets/image-20220204235449767.png)



#### 层次树状结构的域名结构

![image-20220204235922317](computer_network_hnust.assets/image-20220204235922317.png)

#### 顶级域名+二级域名

![image-20220205000709338](computer_network_hnust.assets/image-20220205000709338.png)

- 需要注意的是，名称相同的域名其等级未必相同；例如com是通用顶级域名，但中国顶级域名cn下有一个名称为com的二级域名。

#### 因特网的域名空间

它实际上是一颗倒着生长的树。

![image-20220205001637613](computer_network_hnust.assets/image-20220205001637613.png)

- 图中三级域名mail表示：中国中央电视台的邮件系统
- hunst下的四级域名如nic lib，是hnust自己定义的。



#### 域名服务器类型

![image-20220205002100302](computer_network_hnust.assets/image-20220205002100302.png)



#### 域名解析的过程

![image-20220205003018957](computer_network_hnust.assets/image-20220205003018957.png)

- 迭代查询时，以步骤②③为例；本地域名服务器先向某根域名服务器查询，根域名服务器告诉本地域名服务器下一次应查询的顶级域名服务器的**IP地址**。



#### 域名服务器中的高速缓存

1，

![image-20220205003122271](computer_network_hnust.assets/image-20220205003122271.png)

2，

![image-20220205003254387](computer_network_hnust.assets/image-20220205003254387.png)



#### 小练习

1，

![image-20220205003347622](computer_network_hnust.assets/image-20220205003347622.png)

2，



![image-20220205003416538](computer_network_hnust.assets/image-20220205003416538.png)

#### 小结

![image-20220205003708053](computer_network_hnust.assets/image-20220205003708053.png)

- DNS污染等安全问题，超出本课程教学大纲，有兴趣自己查资料。



### 文件传送协议FTP

https://www.bilibili.com/video/BV1c4411d7jb?p=71&spm_id_from=pageDriver

