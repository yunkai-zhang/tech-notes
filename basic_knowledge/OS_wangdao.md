# os_wangdao

由于有ppt资源，并且ppt中包含了重点，所以本笔记打算不把大多数ppt都截图过来，而只是在听课过程中觉得ppt上无法良好体现和理解的地方在此做笔记。

QQ截图时无法控制图片质量，导致笔记过大；改用snipate截屏。

本笔记所说的重点，除非特意说明，否则默认就是考研的重点。

最开始的“总览”内容不全，是启发式，适合自己考自己；最后的“小结”内容是全的，适合快速阅读。

## 基础大纲

### 课程白嫖指南

本课程是官方的。

课程对应教材：王道408考研书；书中有习题，可以写一写。



### 操作系统的概念+功能+目标

#### 知识总览

![image-20220206143922097](os_wangdao.assets/image-20220206143922097.png)

#### 操作系统的概念

1，计算机系统的层次结构：

![image-20220206144656047](os_wangdao.assets/image-20220206144656047.png)

2，操作系统的定义：

![QQ截图20220206144918](os_wangdao.assets/QQ截图20220206144918.jpg)

- 定义的意群1：从中间往两边看
- 定义的意群2：从下往上看
- 定义的意群3：从上往下看



#### 操作系统的功能和目标

1，操作系统的各个角色分别要实现什么功能：

![image-20220206145518225](os_wangdao.assets/image-20220206145518225.png)

#### 操作系统作为系统管理者，要实现功能

1，功能：

![image-20220206150222063](os_wangdao.assets/image-20220206150222063.png)

#### 操作系统作为用户与计算机之间的接口，要实现功能

1，功能：

![image-20220206151245002](os_wangdao.assets/image-20220206151245002.png)

2，用户接口细说：

![image-20220206151332048](os_wangdao.assets/image-20220206151332048.png)

3，用户接口-联机命令接口：

![image-20220206151509273](os_wangdao.assets/image-20220206151509273.png)

- 体现了交互式，即用户说一句，系统做一句



4，用户接口-脱机命令接口：

![image-20220206151733116](os_wangdao.assets/image-20220206151733116.png)

- 双击.bat文件的时候，操作系统就会一条一条往下执行

5，用户接口-程序接口：

![image-20220206151844665](os_wangdao.assets/image-20220206151844665.png)

注意易混淆的概念：

![image-20220206151934435](os_wangdao.assets/image-20220206151934435.png)

6，图形用户界面细说：

![image-20220206152106282](os_wangdao.assets/image-20220206152106282.png)

7，总结：

![image-20220206152404258](os_wangdao.assets/image-20220206152404258.png)

#### 操作系统作为最接近硬件的层次，要实现功能

1，功能：

![image-20220206152626571](os_wangdao.assets/image-20220206152626571.png)

#### 小结

![image-20220206153018615](os_wangdao.assets/image-20220206153018615.png)

### 操作系统的四个特征

#### 总览

![image-20220206162914493](os_wangdao.assets/image-20220206162914493.png)

#### 并发

1，概念与实例：

![image-20220206163250697](os_wangdao.assets/image-20220206163250697.png)

- 注意并发与并行的区别。

2，多核CPU下，操作系统的“并发性”依然是必不可少的：

![image-20220206163641435](os_wangdao.assets/image-20220206163641435.png)

#### 共享

![image-20220206164405567](os_wangdao.assets/image-20220206164405567.png)

- 有的时候宏观上同时共享，在微观上也确实是同时共享；比如同时玩游戏+听歌，发现扬声器的声音输出设备，一边在播放游戏的音效，同时也在播放音乐；在这种情况下，扬声器这个声音输出设备，在微观上也是同时被音乐播放器和游戏这两个进程同时使用的。



#### 并发和共享的关系

![image-20220206164745661](os_wangdao.assets/image-20220206164745661.png)

- 并发性和共享性是互为存在条件的。



#### 虚拟

1，虚拟定义：

![image-20220206165241831](os_wangdao.assets/image-20220206165241831.png)

2，内存看似不够用，但又够用的原因：

![image-20220206165354101](os_wangdao.assets/image-20220206165354101.png)

3，单核CPU同时运行多个程序的原因：

![image-20220206165204887](os_wangdao.assets/image-20220206165204887.png)

4，有并发性才有虚拟性：

![image-20220206165524235](os_wangdao.assets/image-20220206165524235.png)

#### 异步

![image-20220206170446878](os_wangdao.assets/image-20220206170446878.png)

- 对于上面的约会方法，由于老渣的心只有一颗，在10~11点时，老渣的心被一号占了；2号的指令就没办法得到满足，所以2号的约会任务就会被阻塞，没办法继续往下推进；一直要等到一号使用完老渣的心把它归还给老渣，老渣才能把这颗心分配给2号，然后2号的约会进程才可以继续往下执行。

- 对于下面的约会方法，同样心也是被占用，而导致阻塞。
- 同时可以看出：“并发性是异步性存在的前提”。



#### 小结

![image-20220206170703068](os_wangdao.assets/image-20220206170703068.png)



### 操作系统的发展和分类

#### 总览

![image-20220206170915909](os_wangdao.assets/image-20220206170915909.png)

#### 手工操作阶段

![image-20220206171154895](os_wangdao.assets/image-20220206171154895.png)

#### 单道批处理系统

![image-20220206171850360](os_wangdao.assets/image-20220206171850360.png)

#### 多道批处理系统

1，概念：

![image-20220206172248682](os_wangdao.assets/image-20220206172248682.png)

- 网友说：“以前一个接口读取数据，现在多个接口读取，读取速度增加，cpu空闲时间少，但需要区分程序，引入中断”
- 注意：这里操作系统正式诞生！！！

2，为何说多道批处理系统中，资源利用率大幅提升了：

![image-20220206173650188](os_wangdao.assets/image-20220206173650188.png)

![image-20220206173715388](os_wangdao.assets/image-20220206173715388.png)



- 流水线思想：”输入，计算，输出“在做完上一个产品的自己负责的部分后，就会来下一个产品；不会等一个产品做完了才来下一个。

#### 分时操作系统

![image-20220206174307651](os_wangdao.assets/image-20220206174307651.png)

#### 实时操作系统

![image-20220206174519141](os_wangdao.assets/image-20220206174519141.png)

#### 其他几种操作系统

![image-20220206174553881](os_wangdao.assets/image-20220206174553881.png)

- 在考研的话，这三种操作系统有个印象即可，非重点。



#### 小结

![image-20220206174755563](os_wangdao.assets/image-20220206174755563.png)

- 绿色背景区是重点考察。



### 操作系统的运行机制与体系结构

#### 总览

![image-20220206192348117](os_wangdao.assets/image-20220206192348117.png)

#### 运行机制

1，什么是指令：

![image-20220206192549640](os_wangdao.assets/image-20220206192549640.png)

2，区分特权指令与非特权指令的必要性：

![image-20220206192749880](os_wangdao.assets/image-20220206192749880.png)

3，CPU如何判断当前是否可以执行特权指令：

![image-20220206193005645](os_wangdao.assets/image-20220206193005645.png)

4，运行两种程序，cpu分别处于不同的态：

![image-20220206193703203](os_wangdao.assets/image-20220206193703203.png)

#### 操作系统内核

1，思考：“操作系统·Hong Kong·哪些功能应该由内核程序实现？”。这就引入了操作系统内核的概念。

2，细分操作系统的层次，了解内核：

![image-20220206194359126](os_wangdao.assets/image-20220206194359126.png)

- 所有的进程切换还有进程调度，所有的管理工作，都是需要基于“计时”的功能才能实现；所以时钟管理很重要。

3，内核细节：

![image-20220206195312218](os_wangdao.assets/image-20220206195312218.png)

#### 大内核和微内核

1，不同的操作系统有不同的内核划分标准，所以有大内核操作系统和微内核操作系统：

![image-20220206195611701](os_wangdao.assets/image-20220206195611701.png)

2，大内核与微内核的特点与区别：

![image-20220206200306741](os_wangdao.assets/image-20220206200306741.png)

#### 小结

![image-20220206201057472](os_wangdao.assets/image-20220206201057472.png)

### 中断与异常

#### 总览

![image-20220206202100385](os_wangdao.assets/image-20220206202100385.png)

 #### 中断机制诞生

1，没有中断时：

![image-20220206205454373](os_wangdao.assets/image-20220206205454373.png)

2，引入中断机制。中断发生后，CPU切换到核心态，然后把CPU的使用权限交给系统；操作系统的内核就会对中断信号进行处理；操作系统的内核发现刚才的终端信号是告诉它时间片已到，操作系统就会决定进程1的时间片已用完，换进程2运行

![image-20220206205553324](os_wangdao.assets/image-20220206205553324.png)

- 如上就是操作系统开展的一系列工作，在完成一系列的工作之后，操作系统会把CPU的使用权交还给用户进程，接下来进程2就会在用户态下开始执行



#### 中断的概念和作用

![image-20220206210831562](os_wangdao.assets/image-20220206210831562.png)

#### 中断的分类

1，分类方式一：

![image-20220206211006911](os_wangdao.assets/image-20220206211006911.png)

2，分类方式二：

![image-20220206211054791](os_wangdao.assets/image-20220206211054791.png)

- 我感觉第二种分类和前一种分类区别不大，就记第一种吧。



#### 外中断的处理过程

![image-20220206211257102](os_wangdao.assets/image-20220206211257102.png)

- ”保护被中断进程的CPU环境“的具体操作，是计算机组成原理的内容，这不细说了。



#### 小结

![image-20220206211545449](os_wangdao.assets/image-20220206211545449.png)

### 系统调用

#### 总览

![image-20220206211723548](os_wangdao.assets/image-20220206211723548.png)

#### 系统调用的定义与作用

1，系统调用的定义：

![image-20220206230705728](os_wangdao.assets/image-20220206230705728.png)

2，思考：

![image-20220206231138834](os_wangdao.assets/image-20220206231138834.png)

3，系统调用的作用：

![image-20220206231237040](os_wangdao.assets/image-20220206231237040.png)

4，系统调用的分类：

![image-20220206231700901](os_wangdao.assets/image-20220206231700901.png)

- 简单了解，有个印象即可

5，系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些**特权指令**才能完成，因此**系统调用的相关处理**需要在**核心态**下进行



#### 系统调用和库函数的区别

1，本小节最开始说过：系统调用可以理解为一种可以让应用程序来使用的一些特殊的函数，那么它和我们平时编程使用的库函数有什么区别？：

![image-20220206233222828](os_wangdao.assets/image-20220206233222828.png)

- 其实操作系统对上层会提供“系统调用”接口；应用程序理论上是可以通过汇编语言的形式来直接使用“系统调用”功能的；但是由于现代的软件工程开发过程中，大家其实使用的都是如“C，java”这样的高级语言，所以在现在的编程当中，我们一般在程序中使用高级语言提供的库函数；但是最后这些库函数的底层其实会为我们封装一些相应的系统调用功能，只不过这些细节被库函数屏蔽了，所以使用库函数是很方便的，不需要再用复杂的方式进行系统调用。

#### 系统调用背后的过程

1，过程实例：

![image-20220207001313470](os_wangdao.assets/image-20220207001313470.png)

- 注意的1，这里的”一个内中断”，即“一个interupt”

- 系统调用的背后会执行一个”int指令“（或称为“陷入指令”），这个陷入指令会发出一个内中断，从而使CPU从用户态进入核心态。

2，int x指令，不同的参数x对应什么意思：

![image-20220207001211530](os_wangdao.assets/image-20220207001211530.png)

- 这个了解即可，不需要记。



#### 小结

![image-20220207002105411](os_wangdao.assets/image-20220207002105411.png)



## 进程

### 进程的定义 组成 组成方式 特征

#### 总览

![image-20220207104128655](os_wangdao.assets/image-20220207104128655.png)



#### 进程的定义

1，只支持单道程序的早期计算机阶段：

![image-20220207104917014](os_wangdao.assets/image-20220207104917014.png)

- 早期计算机只支持单道程序，因此在该计算机当中，同一时间段内只能有一道程序正在运行；“CPU，内存，I/O设备”只为该唯一的正在运行的程序服务

2，支持多道程序的计算机阶段：

![image-20220207105333942](os_wangdao.assets/image-20220207105333942.png)

- 本阶段实际上就出现了”进程实体“，即”进程“

3，进程定义：

![image-20220207105909376](os_wangdao.assets/image-20220207105909376.png)

#### 进程的组成

1，进程的组成：

![image-20220207110359986](os_wangdao.assets/image-20220207110359986.png)

2，PCB细节：

![image-20220207111108780](os_wangdao.assets/image-20220207111108780.png)

3，进程的组成，树状图版：

![image-20220207111251912](os_wangdao.assets/image-20220207111251912.png)



#### 进程的组织

1，进程的组织方式有两种：

![image-20220207111817737](os_wangdao.assets/image-20220207111817737.png)

2，进程的组织方式-链接方式：

![image-20220207112134973](os_wangdao.assets/image-20220207112134973.png)

2，进程的组织方式-索引方式：

![image-20220207112645250](os_wangdao.assets/image-20220207112645250.png)

- 索引方式和链接方式很类似，区别就是这些指针指向的是索引表，而不是一个队列的队头；而这个索引表的各个表项又会指向处于本索引表对应状态的各个进程所对应的PCB。
- 简言之，操作系统会为不同状态的进程建立索引表，然后各个索引表的表项又指向处于该状态的各个进程的PCB。



#### 进程的特征

![image-20220207113117996](os_wangdao.assets/image-20220207113117996.png)



#### 小结

![image-20220207113342538](os_wangdao.assets/image-20220207113342538.png)

### 进程的状态与转换

#### 总览

![image-20220207151827765](os_wangdao.assets/image-20220207151827765.png)

#### 进程的状态-三种基本状态

![image-20220207152357480](os_wangdao.assets/image-20220207152357480.png)

#### 进程的状态-另外两种状态

![image-20220207152636218](os_wangdao.assets/image-20220207152636218.png)

#### ！进程状态的转换

![image-20220207153336478](os_wangdao.assets/image-20220207153336478.png)



#### 小结

![image-20220207153733495](os_wangdao.assets/image-20220207153733495.png)

- 绿色背景的为重点



### 进程控制

#### 总览

![image-20220207153833594](os_wangdao.assets/image-20220207153833594.png)

#### 进程控制定义

![image-20220207154107049](os_wangdao.assets/image-20220207154107049.png)

- 进程控制就是要实现绿色箭头表示的具体的过程



#### 如何实现进程控制

1，进程控制的方法：

![image-20220207161215142](os_wangdao.assets/image-20220207161215142.png)

- 就绪态->运行态：

  1. 修改PCB的内容就是把PCB中的状态标志位从“就绪态”改为“运行态”。

  2. 把该进程的PCB从就绪队列中摘出来，然后这个进程既可以被处理 运行。
  3. 这里的“恢复进程运行环境“，是因为这个进程之前可能运行到一半，然后被切换了，所以这个进程运行的一些中间结果其实是被保存在PCB中的，所以这个进程再次被调度的时候需要把它之前的运行环境给恢复过来。

- 运行态->阻塞态：
  1. 当进程在执行的过程当中，如果用系统调用的方式发出了一个等待某个事件的请求，那么就得把这个进程当前运行的环境给保存起来，用于之后这个进程还可以接着往下执行。
  2. 并且还需要把进程的PCB当中的标志位，从运行态改为阻塞态。
  3. 把进程的PCB放到相应时间的阻塞队列中

2，思考：假如对某个进程，把他的PCB从一个队列放到了另一个队列，但是并没有把PCB中的状态标志位改成相应的新的状态，那么是很危险的，可能会造成系统错误；因为PCB所处的队列和PCB当中的状态标志位，两个数据就不一致了。

- 为了防止这个问题出现，就使用了“原语”。

3，原语介绍：

![image-20220207162831444](os_wangdao.assets/image-20220207162831444.png)

- 执行”关中断“指令后，如果此时有外部中断信号进入，那么这个外部中断信号会被忽略而暂时不会被处理；所以这就保证了原语的一系列处理不会被中断。

- 在执行“开中断”指令后，再接收到一个外部中断信号，这个时候才换转入相应的中断处理程序开始处理。
- 可以看出使用“开中断和关中断”就可以实现原语这种一气呵成的操作；也就我们提到的，把PCB放到一个队列当中，并且还需要保证PCB中的数据也被修改，这样的事情就可以用“原语”来实现



#### 进程控制相关的原语

1，原语做的核心三类事情：

![image-20220207163558836](os_wangdao.assets/image-20220207163558836.png)

2，操作系统提供的“创建原语”在创建进程时的作用：

![image-20220207163714098](os_wangdao.assets/image-20220207163714098.png)

- ”创建原语“实现了一个进程从“无”到“创建态”，再从“创建态”进入到就绪队列进入“就绪态”的过程。

3，操作系统提供的“撤销原语”在终止进程时的作用：

![image-20220207164144258](os_wangdao.assets/image-20220207164144258.png)

- 网友说：“ppt有个地方错了，unix中，父进程结束，子进程会被守护进程收养”

- 外界干预：比如使用windows操作系统的任务管理器杀进程，就是一种外界干预

4，操作系统提供的“阻塞原语”和“唤醒原语”的作用：

![image-20220207165045519](os_wangdao.assets/image-20220207165045519.png)

- 网友评价进程阻塞和唤醒的关系：“解铃还须系铃人”

5，操作系统提供的“切换原语”在切换进程时的作用：

![image-20220207164726483](os_wangdao.assets/image-20220207164726483.png)

#### 小结

![image-20220207164854189](os_wangdao.assets/image-20220207164854189.png)



### 进程通信

#### 总览

![image-20220207172747884](os_wangdao.assets/image-20220207172747884.png)

#### 进程通信定义

![image-20220207173228799](os_wangdao.assets/image-20220207173228799.png)

#### 进程通信-共享存储

![image-20220207173644627](os_wangdao.assets/image-20220207173644627.png)

#### 进程通信-管道通信

![image-20220207174456031](os_wangdao.assets/image-20220207174456031.png)

- 互斥：
  - 和共享空间的访问一样；
  - 当进程1正在往管道中写的时候，进程2是不允许访问管道的；只有进程1把管道的访问释放了，进程2才可以开始读。



#### 进程通信-消息传递

![image-20220207175514943](os_wangdao.assets/image-20220207175514943.png)

- 间接通信方式：
  - 信箱中的消息可能是不同进程之间通信的消息；具体是由哪个进程发哪个进程收，这都是在消息头中指定了的，所以不需要担心消息会被取错。
  - 如果一个进程想给另外一个进程发送消息，这个消息会先用发送原语发送到信箱，之后读进程会用接收原语从信箱中取走属于自己的消息。



#### 小结

![image-20220207180229622](os_wangdao.assets/image-20220207180229622.png)

### 线程概念和多线程模型

#### 总览

![image-20220207195948718](os_wangdao.assets/image-20220207195948718.png)

#### 什么是线程，为何引入线程

1，

![image-20220207202311577](os_wangdao.assets/image-20220207202311577.png)

- 图左右对比：
  - 图左边是传统的进程机制；CPU会轮流地为各个进程提供服务，那么这些进程就可以并发地执行；并且每个进程会有它自己相应的一系列程序代码，被CPU服务的时候，这些代码就会**一句一句**(不能并发)往下执行；
  - 图右侧是引入了线程的进程机制；CPU的服务对象就不再是进程，而是进程当中的线程；每一个进程当中可能会包含多个线程，CPU会用一定的算法轮流地为这些线程进行服务；这样同一个进程当中被分为了多个线程，像”QQ视频聊天和QQ传送文件“这两件事情想要并发得执行的话，那我们就可以把”QQ视频聊天和QQ传送文件“对应的处理程序放到两个不同的线程下，那这两个线程可以并发得执行，自然这两件事就可以并发地完成。
- 进程对应着一个程序，而进程内部也需要实现并发所以进程内部引入线程这个概念；如果没有线程，并发执行也只能是进程之间的并发执行，而进程内部依然是顺序执行的。

2，

![image-20220207203209823](os_wangdao.assets/image-20220207203209823.png)

- 知乎总结进程和线程的对比：

  - 地址空间：线程共享本进程的地址空间，而进程之间是独立的地址空间。

  - 资源：线程共享本进程的资源如内存、I/O、cpu等，不利于资源的管理和保护；而进程之间的资源是独立的，能很好的进行资源管理和保护。计算机除CPU以外的系统资源是被分配给进程的，而不是分配给线程的。

  - 健壮性：多进程要比多线程健壮，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。

  - 可并发性：两者均可并发执行。

  - 切换时：进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

  - 其他：线程是处理器(CPU)调度的基本单位，但是进程不是。

    

#### 引入线程机制后，有什么变化

![image-20220207204148910](os_wangdao.assets/image-20220207204148910.png)

- 我理解：”线程是调度的基本单位“即线程是CPU资源分配的基本单位

#### 线程的属性

![image-20220207205501995](os_wangdao.assets/image-20220207205501995.png)

- ”线程控制块TCB“有点类似于之前学过的”PCB进程控制快“，TCB也是用于管理线程所创建的一个数据结构。
- 线程的三种基本状态“就绪，阻塞，运行”，进程也有。
- 线程几乎不拥有系统资源，这是因为资源都在进程那里；线程要资源的话，从自己所属进程那拿。



#### 线程的实现方式

1，用户级线程：

![image-20220207210540284](os_wangdao.assets/image-20220207210540284.png)

- 计算机中的透明：计算机中存在，但是你不需要了解

2，内核级线程：

![image-20220207210857318](os_wangdao.assets/image-20220207210857318.png)

- 本情形下，对用户来说，这个进程拥有三个线程；对操作系统来说，这个进程同样拥有三个线程。

3，有的操作系统只支持用户级线程，有的只支持内核级线程，也有的操作系统同时支持“用户级线程和内核级线程”。在同时支持“用户级线程和内核级线程”的系统中，可以采用二者组合的方式：

![image-20220207211551024](os_wangdao.assets/image-20220207211551024.png)

- 本图中，三个用户级线程映射到了两个内核级线程当中。

- 本图中进程只能被分配两个核，是因为操作系统只看见两个内核级线程。



#### 多线程模型

1，多对一模型：

![image-20220207212111851](os_wangdao.assets/image-20220207212111851.png)

- 线程切换在用户空间(用户态)就可以完成，由应用程序负责完成。
- 网友说：“因为内核级线程才是处理机分配的基本单位，多个用户级映射在一个内核级线程 ，内核认为仅有一个线程 ，当一个用户级线程被阻塞，内核认为所映射的内核级线程被阻塞，故所有映射到该内核级的用户级都被阻塞”

2，一对一模型：

![image-20220207212307637](os_wangdao.assets/image-20220207212307637.png)

- 一对一模型其实变成了纯粹的内核级线程。

3，多对多模型：

![image-20220207212455706](os_wangdao.assets/image-20220207212455706.png)

- 多对多模型是集二者所长。



#### 小结

![image-20220207212711313](os_wangdao.assets/image-20220207212711313.png)

- 一对一的优缺点写反了



### 处理机调度的概念 层次

#### 总览

![image-20220207225508259](os_wangdao.assets/image-20220207225508259.png)

#### 调度的基本概念

![image-20220207230200528](os_wangdao.assets/image-20220207230200528.png)

- 我疑问：”不是内核线程是调度的单位，怎么又是“选择进程分配给它”“
- 网友：“处理机就是cpu核”

#### 调度的三个层次-高级调度

![image-20220207231315827](os_wangdao.assets/image-20220207231315827.png)

- 作业的定义：
  - 网友：“作业：用户在处理某个作业或任务时要求计算机要求计算机所做事情的集合”
  - 网友：“作业（job）是计算机操作者（或是一个叫做作业调度器的程序）交给操作系统的执行单位。 作业包括程序、相应的数据和作业说明书”
  - 网友：“作业是静态的，而进程是动态的。进程是程序的一次执行过程。此外，一个作业可能需要创建多个进程。而一个进程只能对应一个作业，即作业和进程是多对一的关系。”
  - 赞最多的网友：“作业是你交给计算机干的那件事  进程是计算机为了完成你的作业它要干的几件事。。”
  - 网友：“作业是用户在一次事务处理过程中要求计算机系统所作工作的总和，它是用户向计算机系统提交一项工作的基本单位。个人理解是比进程更加全面的一项任务”。
- 网友：“建议跨考的同学先了解一下计算机组成原理后再来学习”-但面试一般不问机组。



#### 调度的三个层次-中级调度

1，中级调度定义：

![image-20220207232516235](os_wangdao.assets/image-20220207232516235.png)

- 网友问：“前面不是说每个作业只调一次，调出一次吗？为什么这里调入内存后还可以调出调入”。网友答：“前面的，只调一次的是高级调度，这是中级”

- 网友：“这只是页面置换算法，国人给起了个好听的名字中级调度”
- 挂起：挂起就是进程数据放外存，PCB留在内存。中级调度：决定将哪个处于挂起状态的进程重新调入内存。挂起和中级调度互逆。

2，补充知识--进程的挂起态与七状态模型：

![image-20220207233505738](os_wangdao.assets/image-20220207233505738.png)

- 注意图中“挂起”和“阻塞”的区别



#### 调度的三个层次-低级调度

![image-20220207234006858](os_wangdao.assets/image-20220207234006858.png)

- 网友：“高级调度是作业调度，中级调度是内存调度，低级调度是进程调度。高级调度主要是按照一定的调度算法把作业从外存调入内存并为作业分配相应的资源建立相应的进程。而中级调度主要是为了对内存空间进行逻辑扩充。”

- 为了实现进程的并发执行，进程调度的频率就可能很高；这样才能让进程在宏观上看是同时(并发)执行的，而微观上，他们是用很快的频率交替执行。
- 注意：本调度是操作系统**最基本的一种调度**。



#### 三层调度的联系和对比

![image-20220207234802599](os_wangdao.assets/image-20220207234802599.png)

- 作业定义：
  - 赞最多的网友：“作业是你交给计算机干的那件事  进程是计算机为了完成你的作业它要干的几件事。。”
- 高级调度和中级调度都是发生在外存和内存之间的调度；区别在于高级调度是面向作业的调度，中级调度是面向进程的调度。
- 低级调度是内存和cpu之间的调度。



#### 小结

![image-20220207234925017](os_wangdao.assets/image-20220207234925017.png)



### 。进程调度的时机 切换与过程 调度方式

#### 总览

![image-20220208111643793](os_wangdao.assets/image-20220208111643793.png)

#### 进程调度的时机

1，可以进程调度和不可以进程调度的情形：

![image-20220208112106788](os_wangdao.assets/image-20220208112106788.png)

- 网友：“应该这么理解： 关中断---->原语---->开中断”

2，注意区分“临界区”和“操作系统内核程序临界区”：

![image-20220208114025163](os_wangdao.assets/image-20220208114025163.png)

- 因为“临界区是访问临界资源的那段代码”，因此，各个进程只能互斥得进入临界区，互斥地执行访问临界资源的代码。
- 左右图解析：
  - 左图：如果还没退出临界区（还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列,但此时就绪队列被锁住了，因此又无法顺利进行进程调度
  - 右图：在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。。。所以，访问普通临界区时，为了提高CPU的利用率，允许进行调度与切换。

- 网友：“进程在请求打印机这样的I/O设备的时候，由运行态变成阻塞态，因而需要用调度程序将就绪队列的进程变为活动态”
- 网友：“普通临界区就是一些IO设备，打印机，因为这类设备的处理会很慢，不可能一致等待打印机工作结束才使用CPU；内核程序临界区在本例是会给就绪队列上一个锁后独自占用资源，并且此时其他进程是无法进入就绪队列的”

3，有的系统中，只允许进程主动放弃处理机；有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机。但是注意，无论在什么系统中，进程在**普通**临界区中是可以进行调度切换的。



#### 进程调度的方式

![image-20220208114908609](os_wangdao.assets/image-20220208114908609.png)

#### 进程的切换与过程

![image-20220208120055244](os_wangdao.assets/image-20220208120055244.png)

- 不能简单的认为“进程切换越频繁，进程的并发度越高”，进程切换过于频繁反而会导致整个系统的效率降低。
  - 网友评价：“并发度高，但效率低”。



#### 小结

![image-20220208120310357](os_wangdao.assets/image-20220208120310357.png)

### 调度算法的评价指标

#### 总览

![image-20220208120724901](os_wangdao.assets/image-20220208120724901.png)

#### CPU利用率

![image-20220208121345425](os_wangdao.assets/image-20220208121345425.png)

#### 系统吞吐量

![image-20220208121654964](os_wangdao.assets/image-20220208121654964.png)

#### 周转时间

1，普通周转时间

![image-20220208122642354](os_wangdao.assets/image-20220208122642354.png)

- 等厕所的例子：
  - 张三排队10分钟，上厕所1分钟，感觉自己很亏
  - 李四排队1分钟，上厕所10分钟；李四的周转时间也是11分钟，只不过这11分钟只有1分钟是用来等待的，所以对于李四来说，这1分钟的等待对他来说没那么糟糕。
  - 如上就是周转时间相同的情况下，作业的实际运行时间长短不同所导致的对于用户的感受的区别

2，带权周转时间：

![image-20220208123147995](os_wangdao.assets/image-20220208123147995.png)

- 带权周转时间肯定是大于等于1的，因为周转时间包含了作业的实际运行时间，故周转时间肯定比作业的实际运行时间更大。
- 用户看重“带权周转时间”，操作系统看重“平均带权周转时间”

#### 等待时间

![image-20220208124303652](os_wangdao.assets/image-20220208124303652.png)

- 我理解：“I/O时，处理机在为I/O服务，虽然本等待进程不占用处理机，但为I/O服务实际上就是在为本作业服务”

#### 响应时间

![image-20220208124619178](os_wangdao.assets/image-20220208124619178.png)

#### 小结

![image-20220208124709016](os_wangdao.assets/image-20220208124709016.png)

- “带权周转时间”比较难理解，不过只要结合排队上厕所的例子就容易理解了。



### FCFS SJF HRRN调度算法

#### 总览

![image-20220208155337681](os_wangdao.assets/image-20220208155337681.png)

#### FCFS

1，FCFS特点：

![image-20220208161843160](os_wangdao.assets/image-20220208161843160.png)

- 排队买奶茶的例子：奶茶店一般都是先来先服务，假如现在你的前面有个人要买20杯奶茶，那这家店做20杯奶茶可能要半小时；虽然说你只买一杯奶茶，做你的奶茶的时间只需要1分钟，但是由于你的前面突然来了一个长进程/长进程，那么对你这个短作业/短进程体验就会很差。
- 不会导致饥饿，因为只要等着，前面的进程总能处理完。

2，FCFS实例讲解：

![image-20220208162006387](os_wangdao.assets/image-20220208162006387.png)

- 因为等待越久说明越早到。P1先到，所以比后面到的等待服务的时间长，可能p4都到了，P1还在等待服务
- 本例进程为纯计算型的进程，表示进程只需要CPU为它服务；所以一个进程到达以后只有两个状态，要么他就是等待被调度，要么它就是处于运行的状态。

- P3的带权周转时间为8，非常大的值；这意味着，这个进程本来只需要很少的时间为它服务，但是它需要等很长的时间才可以被处理完；因此对P3用户来说，可能他的体验很糟糕。



#### SJF

1，SJF特点：

![image-20220208165933896](os_wangdao.assets/image-20220208165933896.png)

- 网友：“说SJF有平均最短时间没啥不严谨的，说白了就是最短时间优先算法分为抢占式和非抢占式，其中抢占式的平均周转时间更短，自然就可以直接说最短时间优先算法是最短的，因为抢占式是它的子类罢了”

2，非抢占式的短作业优先调度算法：

![image-20220208163529418](os_wangdao.assets/image-20220208163529418.png)

- 最开始只有P1，所以P1最先被运行；等P1运行完毕后，其他所有进程也都到达了。

3，抢占式的短作业优先调度算法：

![image-20220208164756123](os_wangdao.assets/image-20220208164756123.png)

计算如下：

![image-20220208164832753](os_wangdao.assets/image-20220208164832753.png)

4，注意几个小细节：

![image-20220208165518184](os_wangdao.assets/image-20220208165518184.png)

- 操作系统这门课和“数学物理”这些基础理学的学科不一样，操作系统对很多算法和概念的说法和定义，不同版本的教材有所不同，并没有一个很严格的说法。考试时判断所有选项吗，选一个错误最少的。



#### HRRN

1，FCFS和SJF两种算法的思考，引入HRRN：

![image-20220208170509374](os_wangdao.assets/image-20220208170509374.png)

2，HRRN特点：

![image-20220208171930547](os_wangdao.assets/image-20220208171930547.png)

- 综合了FCFS和SJF的优点，做了一个折中。

3，HRRN实例：

![image-20220208171732104](os_wangdao.assets/image-20220208171732104.png)

- 本例中，进程都是纯计算型进程，所以并不会有I/O操作，也就是不会主动要求阻塞；因此“主动阻塞”的情况暂时不用考虑。
- 本图中，某时刻时，红色的Px代表此时刻会被处理的进程。
- 本图小错误：P3((3+1)/1=4)



#### 小结

![image-20220208172333256](os_wangdao.assets/image-20220208172333256.png)

- SJF的“最短的”平均等待时间，最短的打了双引号，因为非默认的抢占式的SJF才是最短的。
- 本节学的三种算法，对用户的交互性很差，一般用于早期的批处理系统。



### 调度算法：时间片轮转 优先级 多级反馈队列

#### 总览

![image-20220208193000718](os_wangdao.assets/image-20220208193000718.png)

#### 时间片轮转调度算法

1，时间片轮转调度算法特点：

![image-20220208195651028](os_wangdao.assets/image-20220208195651028.png)

- 时间片太大影响用户和进程交互(增加进程的响应时间)，时间片太小增大系统切换进程的耗时。

2，时间片轮转调度算法实例--时间片大小为2的情况：

0~5时刻：

![image-20220208195803007](os_wangdao.assets/image-20220208195803007.png)

- 网友：“不计算周转时间是因为这里根本就没法知道作业在外存后备队列等待的时间”

6~11时刻：

![image-20220208195914061](os_wangdao.assets/image-20220208195914061.png)

- 网友：“回去翻视频，主动放弃时也会发生调度”

12~16时刻：

![image-20220208200010042](os_wangdao.assets/image-20220208200010042.png)

3，时间片轮转调度算法实例--时间片大小为5的情况：

![image-20220208200056323](os_wangdao.assets/image-20220208200056323.png)

- 网友：“时间片多，进程切换所需的系统开销大，书里不都写着吗= =”

4，如果用FCFS算法，发现结果和时间片大小为5的情况很类似：

时间片较大的情况：

![image-20220208200235033](os_wangdao.assets/image-20220208200235033.png)

时间片较小的情况：

![image-20220208200324148](os_wangdao.assets/image-20220208200324148.png)

- 时间片大小问题：

  - 所以如果时间片太大的话，会增大进程的响应时间，失去了“时间片轮转调度算法”最大的一个优点。退化成FCFS。

  - 切换太频繁的话，系统会花大量时间来处理进程切换
  - 拓展知识，非重点：一般来说，设计时间片时要让切换进程的开销占比不超过1%；



#### 优先级调度算法

1，时间片轮转调度算法特点：

![image-20220208202144857](os_wangdao.assets/image-20220208202144857.png)

- 就算是动态调整进程优先级，也可能会导致饥饿；因为某个进程等待越久，有限级越高，但同时新到的进程的优先级也越来越高，故长时间等待的进程还是可能饥饿。

2，时间片轮转调度算法实例--非抢占式：

![image-20220208202222049](os_wangdao.assets/image-20220208202222049.png)

3，时间片轮转调度算法实例--抢占式：

![image-20220208202339719](os_wangdao.assets/image-20220208202339719.png)

4，补充：

![image-20220208202503961](os_wangdao.assets/image-20220208202503961.png)

- 我们可以认为“高响应比优先算法”是一种“动态优先级调度算法”。



#### 多级反馈队列调度算法

1，思考：

![image-20220208210314727](os_wangdao.assets/image-20220208210314727.png)

2，多级反馈队列调度算法特点：

![image-20220208214315335](os_wangdao.assets/image-20220208214315335.png)

- 优点解析：

  - 有FCFS优点：每个进程刚开始进来的时候，肯定都是被优先处理的，因为刚开始的时候进程的优先级是最高的。
  - 有RR的优点：因为新到达的进程优先级高，所以在第一级队列的话很快被调度，也即可以得到响应。

  - 有SPF的优点：短进程只需要经历过优先级比较高的那几个队列，即执行了几个较短的时间片后就可以完成了；所以这也会导致短进程的平均周转时间会比较理想。
  - 所谓“用户作假”，即一个长进程，把自己的时间说的很短，伪装成短进程。

- 算法可能导致饥饿，因为源源不断地有短进程到达的话，可能短进程在第一级队列被分配一个时间片之后，就可以被处理了；但是已经被降级为更低优先级的那些进程就可能长期得不到服务，从而导致饥饿。

3，多级反馈队列调度算法实例：

![image-20220208212312209](os_wangdao.assets/image-20220208212312209.png)

- 新进程到达时进入第1级队列的队尾；
- 课程的动画比较形象，记不清的话可以回看视频参考动画理解



#### 小结

![image-20220208215031364](os_wangdao.assets/image-20220208215031364.png)



### 进程同步 进程互斥

#### 总览

![image-20220209133002135](os_wangdao.assets/image-20220209133002135.png)

#### 进程同步

1，异步性定义：

![image-20220209133545572](os_wangdao.assets/image-20220209133545572.png)

2，同步定义：

![image-20220209133753413](os_wangdao.assets/image-20220209133753413.png)

#### 进程互斥

1，进程互斥定义：

![image-20220209134347790](os_wangdao.assets/image-20220209134347790.png)

2，互斥访问的四部分：

![image-20220209135500117](os_wangdao.assets/image-20220209135500117.png)

- 临界区：实际用来访问临界资源的那段代码；比如要通过打印机打印输出的话，对打印机执行写操作的代码就要写在临界区里。
- 退出区：负责解除在“进入区”设置的锁。可以把”进入区“和“退出区”理解为上锁和解锁。

3，为了实现互斥访问临界资源，应遵守的规则：

![image-20220209140016941](os_wangdao.assets/image-20220209140016941.png)

- 忙等待：这个进程暂时没办法往下推进，在等待；但是这个进程还一直占用着处理机，使处理机处于一个忙碌的状态而没有办法给别的进程服务。



#### 小结

![image-20220209140413128](os_wangdao.assets/image-20220209140413128.png)

- 厕所例子：
  - 进程同步：张三先上厕所，老八才能开饭；进程间存在顺序问题要解决。
  - 进程互斥：厕所只有一个坑，不能两个人同时用；进程间对临界资源的访问要互斥地进行。



### 进程互斥的软件实现方法

#### 总览

![image-20220209143347674](os_wangdao.assets/image-20220209143347674.png)

#### 单标志法

1，该算法的思想和优点：

![image-20220209144202969](os_wangdao.assets/image-20220209144202969.png)

- turn的初始值是0，表示刚开始只允许P0进入临界区。

- 网友：“while的作用是为了消耗时间片的吧，两个进程都处于就绪队列，就绪队列也是按照时间片进行调度的，进程之间会切换所有需要while语句在这里实现一个时间片的消耗”

2，单标志法的不足：

![image-20220209144345834](os_wangdao.assets/image-20220209144345834.png)

- 违背空闲让进：trun总要落在一个进程的头上，但是可能某时刻所有进程都不想访问(如初始状态)，就落在一个不想访问的进程上；后面如果有进程想访问临界资源，确因为trun落在一个不想访问资源的进程上，而一直等待。



#### 双标志先检查法

1，为了解决”空闲让进“的问题，引入双标志先检查法：

![image-20220209145323054](os_wangdao.assets/image-20220209145323054.png)

- 解决了“空闲让进”的问题：不需要某个进程顶着“要访问进程的帽子”；所以有进程想访问临界资源的话，就不会被其他不想访问临界资源但顶着“要访问临界资源的帽子”的进程所耽误。
- 违反“忙则等待”的原则：原因如图。



#### 双标志后检查法

![image-20220209151456094](os_wangdao.assets/image-20220209151456094.png)

- 我：“双标志后检查法是尝试解决双标志先检查法的问题，但是失败的一个愚蠢的算法”



#### Peterson算法

1，算法思想：

![image-20220209152902097](os_wangdao.assets/image-20220209152902097.png)

- trun用于孔融让梨的过程，让对方先进入临界区。
- 举例子如，P0和P1用①②③⑥⑦⑧的访问顺序：
  1. P0经过①②③进入临界区，先使用临界区；
  2. P1想进入临界区，但是临界区已经被P0使用，便等P0用完后释放临界区，P0经过⑥⑦⑧进入临界区；
  3. 相当于P0和P1串行地访问了临界区。
- 举例子如，P0和P1用①⑥②③⑦⑧③的访问顺序：
  1. P0先来，执行完①后P0时间片用完，P1被处理机服务；
  2. P1执行完⑥后P1的时间片用完，P0被处理机处理；
  3. P0执行②③后卡在③，然后P0的时间片用完，P1被处理机服务；
  4. P1执行完⑦⑧后卡在⑧，然后P1的时间片用完，P0被处理机服务；
  5. P0重新被处理机处理时在执行③循环，发现turn被P1进程改为0了，循环就不满足，于是跳出死循环同时进入临界区
  6. 由于临界区被P0使用，P1得等到P0使用完毕才能用。

2， 上厕所例子：

123：

![image-20220209160613772](os_wangdao.assets/image-20220209160613772.png)

162783：

![image-20220209160926125](os_wangdao.assets/image-20220209160926125.png)

- 本图中，香香相当于P0，臭臭相当于P1。

3，Peterson的问题：

![image-20220209161017987](os_wangdao.assets/image-20220209161017987.png)

- Peterson未遵循”让权等待“：即使P0暂时不能进入临界区，但是它依然会占用CPU，让CPU一直运行while循环，进入一个盲等的状态。

#### 小结

![image-20220209161310004](os_wangdao.assets/image-20220209161310004.png)

- peterson算法比较难理解，结合我记的例子理解。



### 进程互斥的硬件实现方法

#### 总览

![image-20220209165301702](os_wangdao.assets/image-20220209165301702.png)

#### 中断屏蔽方法

![image-20220209165556301](os_wangdao.assets/image-20220209165556301.png)

#### TestAndSet指令、

![image-20220209170323537](os_wangdao.assets/image-20220209170323537.png)

- 硬件实现本算法，看到C语言是为了描述算法。

#### Swap指令

![image-20220209171136313](os_wangdao.assets/image-20220209171136313.png)

#### 小结

![image-20220209171347039](os_wangdao.assets/image-20220209171347039.png)

### 信号量机制

#### 总览

![image-20220209171608205](os_wangdao.assets/image-20220209171608205.png)

#### 信号量定义

![image-20220209172108198](os_wangdao.assets/image-20220209172108198.png)

#### 信号量机制-整型信号量

![image-20220209174147529](os_wangdao.assets/image-20220209174147529.png)

- 这里的`while(S<=0)和S=S-1`其实和双标志检查法中的“先检查后上锁”做的是一样的事情。不过这里是用原语实现，就避免了“并发 异步”导致的问题。

- 老师提出一个不解之处：“如果一个进程暂时进不了临界区，那就意味着它被卡在wait原语的while循环里，既然wait原语是不可被中断的，那么也就意味着当前正在执行while循环的进程是不是一直不会被切换呢？这个地方感觉是不太严谨的地方，但是很多经典教材中都是这么写的，所以我们姑且认为它没有问题，即不会导致一个进程一直占用处理器。”
  - 网友说：“原语：克服了进程异步的特性，使得进程同步。这里是原语，一般来说原语关中断了不会被时间片强制切换啊。原语不可被中断，切换进程肯定是要通过中断的。”
  - 网友说：“通过while不断循环来阻止其他进程访问临界区，在时间片轮回自己后再继续操作达到原子性”
  - 网友说：“老师说的这个问题不就是忙等吗？？？这就是忙等啊，看下让权等待的定义”。我理解：“确实是忙等，但是无法切换时间片导致一个处理机无法为别的进程服务；只在自己时间片内忙等可以接受，但是一直占用处理机忙等我个人感觉不可接受”
  - 网友说：“While这里是方便理解，资源不够进程会被睡眠”

#### 信号量机制-记录型信号量

刚才的“整形信号量”有一个很大的缺陷就是，如果一个进程暂时进不了临界区，即系统资源暂时不够的话，他会一直占用处理机循环检查，从而导致忙等的状态(不满足让权等待的原则)；所以人们又提出了“记录型信号量”：

![image-20220209175501918](os_wangdao.assets/image-20220209175501918.png)

#### 信号量机制-记录型信号量实例

1，初始状态如下：

![image-20220209193221255](os_wangdao.assets/image-20220209193221255.png)

2，假如说刚开始CPU是为P0服务，当他执行到wait原语的时候，首先会执行的事情是`value --`，所以S.value的值会由2减为1：

![image-20220209193549718](os_wangdao.assets/image-20220209193549718.png)

3，系统判断此时是有打印机资源的，所以把其中的一个打印机分配给P0进程，然后P0可以往下使用打印机：

![image-20220209193651767](os_wangdao.assets/image-20220209193651767.png)

4，之后时间片切换，CPU为P1进程服务；P1进程执行wait原语的时候就是申请一个打印机资源，首先会让S.value减1使之从1变为0：

![image-20220209193911381](os_wangdao.assets/image-20220209193911381.png)

5，之后系统会把打印机分配给P1进程，然后P1进程开始使用打印机：

![image-20220209194014655](os_wangdao.assets/image-20220209194014655.png)

- 我们可以看到，当**S.value=0**的时候，此时系统中所有的打印机刚好全部分配给了某一些进程，说明**资源恰好分配完毕**。

6，接下来时间片切换，CPU为P2进程服务；P2进程同样需要使用打印机资源，它在执行wait原语的时候，同样S.value减一使之从0变为-1；当S.value在减一后小于零说明此时系统当中没有多余的资源(打印机)可以分配给当前的P2进程，因此P2进程主动在wait原语当中执行block原语(把本进程阻塞的原语)，所以P2进程会被挂到打印机这种资源的等待队列里：

![image-20220209195238213](os_wangdao.assets/image-20220209195238213.png)

- 此时我们可以发现，当S.value=-1时，有1个(S.value的绝对值个数目)进程在等待打印机资源。

7，接下来P2时间片结束，CPU转向为P3进程服务；P3进程同样需要使用打印机资源，它在执行wait原语的时候，同样S.value减一使之从-1变为-2；当S.value在减一后小于零说明此时系统中的打印机资源已经分配完毕，所以P3进程也会主动执行block原语，因此P3进程也会被插入相应的等待队列的队尾：

![image-20220209195951653](os_wangdao.assets/image-20220209195951653.png)

8，由于P2和P3都执行了block原语被阻塞，因此P3时间片过后CPU只能为P0和P1服务。

9，假设接下来CPU是为P0进程服务的；P0在使用完打印机后执行了signal原语，即让S.value加1使之从-2变为-1；如果S.value在加一之后还是<=0，那么就说明此时在等待队列中依然有一些进程在等待，所以P0在signal原语当中会主动执行一个wakeup原语，用来唤醒信号量的等待队列的队头的进程即P2，所有P2进程会从阻塞队列放回就绪队列，并且会把P0刚释放的打印机资源分配给P2：

![image-20220209201125671](os_wangdao.assets/image-20220209201125671.png)

10，P0在执行完其他语句之后就执行完毕了，若P时间片过后CPU接着为P2进程服务；P2就可以开始使用打印机资源：

![image-20220209201326973](os_wangdao.assets/image-20220209201326973.png)

11，P2使用完打印机资源后，会执行signal原语对打印机资源释放；同样的，进程会对S.value的值加一使之从-1变为0；由于S.value加一后仍然是小于等于0的，所以说明此时在信号量的等待队列当中还是有进程在等待打印机资源，所以它也会执行一个wakeup原语来唤醒此时处于信号量的等待队列队头的进程即P3；因此执行完wakup原语后P3进程会从阻塞态变回就绪态，并且P2刚才释放的打印机资源会被分配给P3，同时P3的信息会从信号量的等待队列消失，这样等待队列就变为空了：

![image-20220209202020025](os_wangdao.assets/image-20220209202020025.png)

12，接下来P2在执行完剩余的代码就结束了，假设P1时间片结束后之后CPU又回到了为P1服务；那么P1使用打印机：

![image-20220209202812459](os_wangdao.assets/image-20220209202812459.png)

13，P1使用完打印机后又会对打印机资源进行释放，此时首先对S.value加一使之从0变为1；由于S.value加一后已经大于0了，所以此时在等待队列中没有进程在等待，所以P1进程在执行Signal操作的时候并不需要执行wakeup原语；接下来系统会回收分配给P1的打印机资源，然后P1得以继续往下执行：

![image-20220209203209142](os_wangdao.assets/image-20220209203209142.png)

14，最后还有P3进程没有结束，所以CPU为P3进程服务；P3使用打印机：

![image-20220209203337117](os_wangdao.assets/image-20220209203337117.png)

15，P3使用完打印机后对打印机资源进行释放；S.value加一使之从1变为2；之后系统回收打印机资源：

![image-20220209203559090](os_wangdao.assets/image-20220209203559090.png)

16，P3得以顺利地执行，最后结束。

![image-20220209203640555](os_wangdao.assets/image-20220209203640555.png)



17，记录型信号总结：

![image-20220209203911171](os_wangdao.assets/image-20220209203911171.png)

- 网友：“这已经是让权等待了啊。厕所门堵了，你进不去，那你就别站门口，去后面排队。等厕所里人出来了，等着的人再从队列里再按顺序进厕所。”

#### 小结

![image-20220209204035952](os_wangdao.assets/image-20220209204035952.png)

- 记录型信号量是操作系统中最重要的知识点！！



### 用信号量实现进程互斥 同步 前驱关系

#### 信号量机制实现进程互斥

1，

![image-20220209223446578](os_wangdao.assets/image-20220209223446578.png)

- 如果有两个进程都需要访问临界资源打印机的话，那么对打印机进行访问的代码就应该归属于临界区内。
- 信号量的初值表示系统中某种资源的数量。我们这提到的临界区，其实同一个时间段只允许一个进程对它进行访问；所以我们可以把临界区理解为一种特殊的资源，而这个资源只有一个，也就是说临界区只能被分配给一个进程使用；只有一个进程释放了临界区资源后，它才可以由另外的进程来使用；所以使用临界区资源之前要加P，使用临界区资源之后要加V
- 正规的信号量的值是卸载structure里的，但是可以如图形式简写信号量。



#### 信号量机制实现进程同步

1，进程同步的概念：

![image-20220209224154102](os_wangdao.assets/image-20220209224154102.png)

- 并发带来了异步性，所以P1和P2的相互切换和进程中代码的推进顺序是不可预知的。
  - 比如代码执行顺序可能是：145236

2，信号量机制实现进程同步：

![image-20220209225938922](os_wangdao.assets/image-20220209225938922.png)

- 本例中，代码4一定要在代码1和代码2后执行。
- “前操作”，表示进程同步问题中，必须在前面执行的操作；“后操作”，表示进程同步问题中，必须在后面执行的操作。



#### 信号量机制实现前驱关系

![image-20220209230737995](os_wangdao.assets/image-20220209230737995.png)

- 图中S2执行完了，才能执行S4和S5。



#### 小结

![image-20220209232022574](os_wangdao.assets/image-20220209232022574.png)

- 回忆：P V分别是wait(-- 且block)和signal(++ 且wakeup)
- 有多少系统资源，就要把信号量的初始值设置为多少。



### 生产者-消费者问题

https://www.bilibili.com/video/BV1YE411D7nH?p=23&spm_id_from=pageDriver

